--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -153,1305 +_,2474 @@
 import org.slf4j.Logger;
 
 public class ServerGamePacketListenerImpl implements ServerPlayerConnection, ServerGamePacketListener {
-   static final Logger LOGGER = LogUtils.getLogger();
-   private static final int LATENCY_CHECK_INTERVAL = 15000;
-   public final Connection connection;
-   private final MinecraftServer server;
-   public ServerPlayer player;
-   private int tickCount;
-   private long keepAliveTime;
-   private boolean keepAlivePending;
-   private long keepAliveChallenge;
-   private int chatSpamTickCount;
-   private int dropSpamTickCount;
-   private double firstGoodX;
-   private double firstGoodY;
-   private double firstGoodZ;
-   private double lastGoodX;
-   private double lastGoodY;
-   private double lastGoodZ;
-   @Nullable
-   private Entity lastVehicle;
-   private double vehicleFirstGoodX;
-   private double vehicleFirstGoodY;
-   private double vehicleFirstGoodZ;
-   private double vehicleLastGoodX;
-   private double vehicleLastGoodY;
-   private double vehicleLastGoodZ;
-   @Nullable
-   private Vec3 awaitingPositionFromClient;
-   private int awaitingTeleport;
-   private int awaitingTeleportTime;
-   private boolean clientIsFloating;
-   private int aboveGroundTickCount;
-   private boolean clientVehicleIsFloating;
-   private int aboveGroundVehicleTickCount;
-   private int receivedMovePacketCount;
-   private int knownMovePacketCount;
-
-   public ServerGamePacketListenerImpl(MinecraftServer p_9770_, Connection p_9771_, ServerPlayer p_9772_) {
-      this.server = p_9770_;
-      this.connection = p_9771_;
-      p_9771_.setListener(this);
-      this.player = p_9772_;
-      p_9772_.connection = this;
-      this.keepAliveTime = Util.getMillis();
-      p_9772_.getTextFilter().join();
-   }
-
-   public void tick() {
-      this.resetPosition();
-      this.player.xo = this.player.getX();
-      this.player.yo = this.player.getY();
-      this.player.zo = this.player.getZ();
-      this.player.doTick();
-      this.player.absMoveTo(this.firstGoodX, this.firstGoodY, this.firstGoodZ, this.player.getYRot(), this.player.getXRot());
-      ++this.tickCount;
-      this.knownMovePacketCount = this.receivedMovePacketCount;
-      if (this.clientIsFloating && !this.player.isSleeping() && !this.player.isPassenger()) {
-         if (++this.aboveGroundTickCount > 80) {
-            LOGGER.warn("{} was kicked for floating too long!", (Object)this.player.getName().getString());
-            this.disconnect(new TranslatableComponent("multiplayer.disconnect.flying"));
-            return;
-         }
-      } else {
-         this.clientIsFloating = false;
-         this.aboveGroundTickCount = 0;
-      }
-
-      this.lastVehicle = this.player.getRootVehicle();
-      if (this.lastVehicle != this.player && this.lastVehicle.getControllingPassenger() == this.player) {
-         this.vehicleFirstGoodX = this.lastVehicle.getX();
-         this.vehicleFirstGoodY = this.lastVehicle.getY();
-         this.vehicleFirstGoodZ = this.lastVehicle.getZ();
-         this.vehicleLastGoodX = this.lastVehicle.getX();
-         this.vehicleLastGoodY = this.lastVehicle.getY();
-         this.vehicleLastGoodZ = this.lastVehicle.getZ();
-         if (this.clientVehicleIsFloating && this.player.getRootVehicle().getControllingPassenger() == this.player) {
-            if (++this.aboveGroundVehicleTickCount > 80) {
-               LOGGER.warn("{} was kicked for floating a vehicle too long!", (Object)this.player.getName().getString());
-               this.disconnect(new TranslatableComponent("multiplayer.disconnect.flying"));
-               return;
-            }
-         } else {
+    static final Logger LOGGER = LogUtils.getLogger();
+    private static final int LATENCY_CHECK_INTERVAL = 15000;
+    public final Connection connection;
+    private final MinecraftServer server;
+    public ServerPlayer player;
+    private int tickCount;
+    private long keepAliveTime;
+    private boolean keepAlivePending;
+    private long keepAliveChallenge;
+    //Magma start - remove craftbukkit multithreading
+    public int chatSpamTickCount;
+    //Magma end
+    private int dropSpamTickCount;
+    private double firstGoodX;
+    private double firstGoodY;
+    private double firstGoodZ;
+    private double lastGoodX;
+    private double lastGoodY;
+    private double lastGoodZ;
+    @Nullable
+    private Entity lastVehicle;
+    private double vehicleFirstGoodX;
+    private double vehicleFirstGoodY;
+    private double vehicleFirstGoodZ;
+    private double vehicleLastGoodX;
+    private double vehicleLastGoodY;
+    private double vehicleLastGoodZ;
+    @Nullable
+    private Vec3 awaitingPositionFromClient;
+    private int awaitingTeleport;
+    private int awaitingTeleportTime;
+    private boolean clientIsFloating;
+    private int aboveGroundTickCount;
+    private boolean clientVehicleIsFloating;
+    private int aboveGroundVehicleTickCount;
+    private int receivedMovePacketCount;
+    private int knownMovePacketCount;
+
+
+    public ServerGamePacketListenerImpl(MinecraftServer p_9770_, Connection p_9771_, ServerPlayer p_9772_) {
+        this.server = p_9770_;
+        this.connection = p_9771_;
+        p_9771_.setListener( this );
+        this.player = p_9772_;
+        p_9772_.connection = this;
+        this.keepAliveTime = Util.getMillis();
+        p_9772_.getTextFilter().join();
+
+        // CraftBukkit start - add fields and methods
+        this.cserver = p_9770_.server;
+    }
+
+    private final org.bukkit.craftbukkit.v1_18_R2.CraftServer cserver;
+    public boolean processedDisconnect;
+    private int lastTick = MinecraftServer.currentTick;
+    private int allowedPlayerTicks = 1;
+    private int lastDropTick = MinecraftServer.currentTick;
+    private int lastBookTick = MinecraftServer.currentTick;
+    private int dropCount = 0;
+
+    // Get position of last block hit for BlockDamageLevel.STOPPED
+    private double lastPosX = Double.MAX_VALUE;
+    private double lastPosY = Double.MAX_VALUE;
+    private double lastPosZ = Double.MAX_VALUE;
+    private float lastPitch = Float.MAX_VALUE;
+    private float lastYaw = Float.MAX_VALUE;
+    private boolean justTeleported = false;
+    private boolean hasMoved; // Spigot
+
+    public org.bukkit.craftbukkit.v1_18_R2.entity.CraftPlayer getCraftPlayer() {
+        return (this.player == null) ? null : (org.bukkit.craftbukkit.v1_18_R2.entity.CraftPlayer) this.player.getBukkitEntity();
+    }
+    // CraftBukkit end
+
+    public void tick() {
+        this.resetPosition();
+        this.player.xo = this.player.getX();
+        this.player.yo = this.player.getY();
+        this.player.zo = this.player.getZ();
+        this.player.doTick();
+        this.player.absMoveTo( this.firstGoodX, this.firstGoodY, this.firstGoodZ, this.player.getYRot(), this.player.getXRot() );
+        ++this.tickCount;
+        this.knownMovePacketCount = this.receivedMovePacketCount;
+        if (this.clientIsFloating && !this.player.isSleeping() && !this.player.isPassenger()) {
+            if (++this.aboveGroundTickCount > 80) {
+                LOGGER.warn( "{} was kicked for floating too long!", (Object) this.player.getName().getString() );
+                this.disconnect( new TranslatableComponent( "multiplayer.disconnect.flying" ) );
+                return;
+            }
+        } else {
+            this.clientIsFloating = false;
+            this.aboveGroundTickCount = 0;
+        }
+
+        this.lastVehicle = this.player.getRootVehicle();
+        if (this.lastVehicle != this.player && this.lastVehicle.getControllingPassenger() == this.player) {
+            this.vehicleFirstGoodX = this.lastVehicle.getX();
+            this.vehicleFirstGoodY = this.lastVehicle.getY();
+            this.vehicleFirstGoodZ = this.lastVehicle.getZ();
+            this.vehicleLastGoodX = this.lastVehicle.getX();
+            this.vehicleLastGoodY = this.lastVehicle.getY();
+            this.vehicleLastGoodZ = this.lastVehicle.getZ();
+            if (this.clientVehicleIsFloating && this.player.getRootVehicle().getControllingPassenger() == this.player) {
+                if (++this.aboveGroundVehicleTickCount > 80) {
+                    LOGGER.warn( "{} was kicked for floating a vehicle too long!", (Object) this.player.getName().getString() );
+                    this.disconnect( new TranslatableComponent( "multiplayer.disconnect.flying" ) );
+                    return;
+                }
+            } else {
+                this.clientVehicleIsFloating = false;
+                this.aboveGroundVehicleTickCount = 0;
+            }
+        } else {
+            this.lastVehicle = null;
             this.clientVehicleIsFloating = false;
             this.aboveGroundVehicleTickCount = 0;
-         }
-      } else {
-         this.lastVehicle = null;
-         this.clientVehicleIsFloating = false;
-         this.aboveGroundVehicleTickCount = 0;
-      }
-
-      this.server.getProfiler().push("keepAlive");
-      long i = Util.getMillis();
-      if (i - this.keepAliveTime >= 15000L) {
-         if (this.keepAlivePending) {
-            this.disconnect(new TranslatableComponent("disconnect.timeout"));
-         } else {
-            this.keepAlivePending = true;
-            this.keepAliveTime = i;
-            this.keepAliveChallenge = i;
-            this.send(new ClientboundKeepAlivePacket(this.keepAliveChallenge));
-         }
-      }
-
-      this.server.getProfiler().pop();
-      if (this.chatSpamTickCount > 0) {
-         --this.chatSpamTickCount;
-      }
-
-      if (this.dropSpamTickCount > 0) {
-         --this.dropSpamTickCount;
-      }
-
-      if (this.player.getLastActionTime() > 0L && this.server.getPlayerIdleTimeout() > 0 && Util.getMillis() - this.player.getLastActionTime() > (long)(this.server.getPlayerIdleTimeout() * 1000 * 60)) {
-         this.disconnect(new TranslatableComponent("multiplayer.disconnect.idling"));
-      }
-
-   }
-
-   public void resetPosition() {
-      this.firstGoodX = this.player.getX();
-      this.firstGoodY = this.player.getY();
-      this.firstGoodZ = this.player.getZ();
-      this.lastGoodX = this.player.getX();
-      this.lastGoodY = this.player.getY();
-      this.lastGoodZ = this.player.getZ();
-   }
-
-   public Connection getConnection() {
-      return this.connection;
-   }
-
-   private boolean isSingleplayerOwner() {
-      return this.server.isSingleplayerOwner(this.player.getGameProfile());
-   }
-
-   public void disconnect(Component p_9943_) {
-      this.connection.send(new ClientboundDisconnectPacket(p_9943_), (p_9828_) -> {
-         this.connection.disconnect(p_9943_);
-      });
-      this.connection.setReadOnly();
-      this.server.executeBlocking(this.connection::handleDisconnection);
-   }
-
-   private <T, R> void filterTextPacket(T p_9802_, Consumer<R> p_9803_, BiFunction<TextFilter, T, CompletableFuture<R>> p_9804_) {
-      BlockableEventLoop<?> blockableeventloop = this.player.getLevel().getServer();
-      Consumer<R> consumer = (p_201923_) -> {
-         if (this.getConnection().isConnected()) {
-            try {
-               p_9803_.accept(p_201923_);
-            } catch (Exception exception) {
-               LOGGER.error("Failed to handle chat packet {}, suppressing error", p_9802_, exception);
-            }
-         } else {
-            LOGGER.debug("Ignoring packet due to disconnection");
-         }
-
-      };
-      p_9804_.apply(this.player.getTextFilter(), p_9802_).thenAcceptAsync(consumer, blockableeventloop);
-   }
-
-   private void filterTextPacket(String p_9810_, Consumer<TextFilter.FilteredText> p_9811_) {
-      this.filterTextPacket(p_9810_, p_9811_, TextFilter::processStreamMessage);
-   }
-
-   private void filterTextPacket(List<String> p_9816_, Consumer<List<TextFilter.FilteredText>> p_9817_) {
-      this.filterTextPacket(p_9816_, p_9817_, TextFilter::processMessageBundle);
-   }
-
-   public void handlePlayerInput(ServerboundPlayerInputPacket p_9893_) {
-      PacketUtils.ensureRunningOnSameThread(p_9893_, this, this.player.getLevel());
-      this.player.setPlayerInput(p_9893_.getXxa(), p_9893_.getZza(), p_9893_.isJumping(), p_9893_.isShiftKeyDown());
-   }
-
-   private static boolean containsInvalidValues(double p_143664_, double p_143665_, double p_143666_, float p_143667_, float p_143668_) {
-      return Double.isNaN(p_143664_) || Double.isNaN(p_143665_) || Double.isNaN(p_143666_) || !Floats.isFinite(p_143668_) || !Floats.isFinite(p_143667_);
-   }
-
-   private static double clampHorizontal(double p_143610_) {
-      return Mth.clamp(p_143610_, -3.0E7D, 3.0E7D);
-   }
-
-   private static double clampVertical(double p_143654_) {
-      return Mth.clamp(p_143654_, -2.0E7D, 2.0E7D);
-   }
-
-   public void handleMoveVehicle(ServerboundMoveVehiclePacket p_9876_) {
-      PacketUtils.ensureRunningOnSameThread(p_9876_, this, this.player.getLevel());
-      if (containsInvalidValues(p_9876_.getX(), p_9876_.getY(), p_9876_.getZ(), p_9876_.getYRot(), p_9876_.getXRot())) {
-         this.disconnect(new TranslatableComponent("multiplayer.disconnect.invalid_vehicle_movement"));
-      } else {
-         Entity entity = this.player.getRootVehicle();
-         if (entity != this.player && entity.getControllingPassenger() == this.player && entity == this.lastVehicle) {
+        }
+
+        this.server.getProfiler().push( "keepAlive" );
+        long i = Util.getMillis();
+        if (i - this.keepAliveTime >= 25000L) { // CraftBukkit
+            if (this.keepAlivePending) {
+                this.disconnect( new TranslatableComponent( "disconnect.timeout" ) );
+            } else {
+                this.keepAlivePending = true;
+                this.keepAliveTime = i;
+                this.keepAliveChallenge = i;
+                this.send( new ClientboundKeepAlivePacket( this.keepAliveChallenge ) );
+            }
+        }
+
+        this.server.getProfiler().pop();
+        if (this.chatSpamTickCount > 0) {
+            --this.chatSpamTickCount;
+        }
+
+        if (this.dropSpamTickCount > 0) {
+            --this.dropSpamTickCount;
+        }
+
+        if (this.player.getLastActionTime() > 0L && this.server.getPlayerIdleTimeout() > 0 && Util.getMillis() - this.player.getLastActionTime() > (long) (this.server.getPlayerIdleTimeout() * 1000 * 60)) {
+            this.player.resetLastActionTime(); // CraftBukkit - SPIGOT-854
+            this.disconnect( new TranslatableComponent( "multiplayer.disconnect.idling" ) );
+        }
+
+    }
+
+    public void resetPosition() {
+        this.firstGoodX = this.player.getX();
+        this.firstGoodY = this.player.getY();
+        this.firstGoodZ = this.player.getZ();
+        this.lastGoodX = this.player.getX();
+        this.lastGoodY = this.player.getY();
+        this.lastGoodZ = this.player.getZ();
+    }
+
+    public Connection getConnection() {
+        return this.connection;
+    }
+
+    private boolean isSingleplayerOwner() {
+        return this.server.isSingleplayerOwner( this.player.getGameProfile() );
+    }
+
+    // CraftBukkit start
+    @Deprecated
+    public void disconnect(Component p_9943_) {
+        disconnect(org.bukkit.craftbukkit.v1_18_R2.util.CraftChatMessage.fromComponent(p_9943_));
+    }
+
+    // CraftBukkit end
+    public void disconnect(String s) {
+        // CraftBukkit start - fire PlayerKickEvent
+        if (this.processedDisconnect) {
+            return;
+        }
+        String leaveMessage = ChatFormatting.YELLOW + this.player.getScoreboardName() + " left the game";
+
+        org.bukkit.event.player.PlayerKickEvent event = new org.bukkit.event.player.PlayerKickEvent(this.player.getBukkitEntity(), s, leaveMessage);
+
+        if (this.cserver.getServer().isRunning()) {
+            this.cserver.getPluginManager().callEvent(event);
+        }
+
+        if (event.isCancelled()) {
+            // Do not kick the player
+            return;
+        }
+        this.player.kickLeaveMessage = event.getLeaveMessage(); // CraftBukkit - SPIGOT-3034: Forward leave message to PlayerQuitEvent
+        // Send the possibly modified leave message
+        doDisconnect(event.getReason());//Magma extract actual disconnect into seperate method
+    }
+    public void doDisconnect(String s){
+        if (this.processedDisconnect) {
+            return;
+        }
+        final Component p_9943_ = org.bukkit.craftbukkit.v1_18_R2.util.CraftChatMessage.fromString(s, true)[0];
+        // CraftBukkit end
+
+        this.connection.send( new ClientboundDisconnectPacket( p_9943_ ), (p_9828_) -> {
+            this.connection.disconnect( p_9943_ );
+        } );
+        this.onDisconnect(p_9943_); // CraftBukkit - fire quit instantly
+        this.connection.setReadOnly();
+        // CraftBukkit - Don't wait
+        this.server.wrapRunnable(this.connection::handleDisconnection);
+    }
+
+    private <T, R> void filterTextPacket(T p_9802_, Consumer<R> p_9803_, BiFunction<TextFilter, T, CompletableFuture<R>> p_9804_) {
+        BlockableEventLoop<?> blockableeventloop = this.player.getLevel().getServer();
+        Consumer<R> consumer = (p_201923_) -> {
+            if (this.getConnection().isConnected()) {
+                try {
+                    p_9803_.accept( p_201923_ );
+                } catch (Exception exception) {
+                    LOGGER.error( "Failed to handle chat packet {}, suppressing error", p_9802_, exception );
+                }
+            } else {
+                LOGGER.debug( "Ignoring packet due to disconnection" );
+            }
+
+        };
+        p_9804_.apply( this.player.getTextFilter(), p_9802_ ).thenAcceptAsync( consumer, blockableeventloop );
+    }
+
+    private void filterTextPacket(String p_9810_, Consumer<TextFilter.FilteredText> p_9811_) {
+        this.filterTextPacket( p_9810_, p_9811_, TextFilter::processStreamMessage );
+    }
+
+    private void filterTextPacket(List<String> p_9816_, Consumer<List<TextFilter.FilteredText>> p_9817_) {
+        this.filterTextPacket( p_9816_, p_9817_, TextFilter::processMessageBundle );
+    }
+
+    public void handlePlayerInput(ServerboundPlayerInputPacket p_9893_) {
+        PacketUtils.ensureRunningOnSameThread( p_9893_, this, this.player.getLevel() );
+        this.player.setPlayerInput( p_9893_.getXxa(), p_9893_.getZza(), p_9893_.isJumping(), p_9893_.isShiftKeyDown() );
+    }
+
+    private static boolean containsInvalidValues(double p_143664_, double p_143665_, double p_143666_, float p_143667_, float p_143668_) {
+        return Double.isNaN( p_143664_ ) || Double.isNaN( p_143665_ ) || Double.isNaN( p_143666_ ) || !Floats.isFinite( p_143668_ ) || !Floats.isFinite( p_143667_ );
+    }
+
+    private static double clampHorizontal(double p_143610_) {
+        return Mth.clamp( p_143610_, -3.0E7D, 3.0E7D );
+    }
+
+    private static double clampVertical(double p_143654_) {
+        return Mth.clamp( p_143654_, -2.0E7D, 2.0E7D );
+    }
+
+    public void handleMoveVehicle(ServerboundMoveVehiclePacket p_9876_) {
+        PacketUtils.ensureRunningOnSameThread( p_9876_, this, this.player.getLevel() );
+        if (containsInvalidValues( p_9876_.getX(), p_9876_.getY(), p_9876_.getZ(), p_9876_.getYRot(), p_9876_.getXRot() )) {
+            this.disconnect( new TranslatableComponent( "multiplayer.disconnect.invalid_vehicle_movement" ) );
+        } else {
+            Entity entity = this.player.getRootVehicle();
+            if (entity != this.player && entity.getControllingPassenger() == this.player && entity == this.lastVehicle) {
+                ServerLevel serverlevel = this.player.getLevel();
+                double d0 = entity.getX();
+                double d1 = entity.getY();
+                double d2 = entity.getZ();
+                double d3 = clampHorizontal( p_9876_.getX() );
+                double d4 = clampVertical( p_9876_.getY() );
+                double d5 = clampHorizontal( p_9876_.getZ() );
+                float f = Mth.wrapDegrees( p_9876_.getYRot() );
+                float f1 = Mth.wrapDegrees( p_9876_.getXRot() );
+                double d6 = d3 - this.vehicleFirstGoodX;
+                double d7 = d4 - this.vehicleFirstGoodY;
+                double d8 = d5 - this.vehicleFirstGoodZ;
+                double d9 = entity.getDeltaMovement().lengthSqr();
+                double d10 = d6 * d6 + d7 * d7 + d8 * d8;
+
+                // CraftBukkit start - handle custom speeds and skipped ticks
+                this.allowedPlayerTicks += (System.currentTimeMillis() / 50) - this.lastTick;
+                this.allowedPlayerTicks = Math.max(this.allowedPlayerTicks, 1);
+                this.lastTick = (int) (System.currentTimeMillis() / 50);
+
+                ++this.receivedMovePacketCount;
+                int i = this.receivedMovePacketCount - this.knownMovePacketCount;
+                if (i > Math.max(this.allowedPlayerTicks, 5)) {
+                    ServerGamePacketListenerImpl.LOGGER.debug(this.player.getScoreboardName() + " is sending move packets too frequently (" + i + " packets since last tick)");
+                    i = 1;
+                }
+
+                if (d10 > 0) {
+                    allowedPlayerTicks -= 1;
+                } else {
+                    allowedPlayerTicks = 20;
+                }
+                double speed;
+                if (player.getAbilities().flying) {
+                    speed = player.getAbilities().flyingSpeed * 20f;
+                } else {
+                    speed = player.getAbilities().walkingSpeed * 10f;
+                }
+                speed *= 2f; // TODO: Get the speed of the vehicle instead of the player
+
+                if (d10 - d9 > Math.max(100.0D, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && !this.isSingleplayerOwner()) {
+                    // CraftBukkit end
+                    LOGGER.warn( "{} (vehicle of {}) moved too quickly! {},{},{}", entity.getName().getString(), this.player.getName().getString(), d6, d7, d8 );
+                    this.connection.send( new ClientboundMoveVehiclePacket( entity ) );
+                    return;
+                }
+
+                boolean flag = serverlevel.noCollision( entity, entity.getBoundingBox().deflate( 0.0625D ) );
+                d6 = d3 - this.vehicleLastGoodX;
+                d7 = d4 - this.vehicleLastGoodY - 1.0E-6D;
+                d8 = d5 - this.vehicleLastGoodZ;
+                boolean flag1 = entity.verticalCollisionBelow;
+                entity.move( MoverType.PLAYER, new Vec3( d6, d7, d8 ) );
+                d6 = d3 - entity.getX();
+                d7 = d4 - entity.getY();
+                if (d7 > -0.5D || d7 < 0.5D) {
+                    d7 = 0.0D;
+                }
+
+                d8 = d5 - entity.getZ();
+                d10 = d6 * d6 + d7 * d7 + d8 * d8;
+                boolean flag2 = false;
+
+                if (d10 > org.spigotmc.SpigotConfig.movedWronglyThreshold) { // Spigot
+                    flag2 = true;
+                    LOGGER.warn( "{} (vehicle of {}) moved wrongly! {}", entity.getName().getString(), this.player.getName().getString(), Math.sqrt( d10 ) );
+                }
+                org.bukkit.Location curPos = this.getCraftPlayer().getLocation(); // Spigot
+
+                entity.absMoveTo( d3, d4, d5, f, f1 );
+                player.absMoveTo(d3, d4, d5, this.player.getYRot(), this.player.getXRot()); // CraftBukkit
+                this.player.absMoveTo( d3, d4, d5, this.player.getYRot(), this.player.getXRot() ); // Forge - Resync player position on vehicle moving
+                boolean flag3 = serverlevel.noCollision( entity, entity.getBoundingBox().deflate( 0.0625D ) );
+                if (flag && (flag2 || !flag3)) {
+                    entity.absMoveTo( d0, d1, d2, f, f1 );
+                    player.absMoveTo(d0, d1, d2, this.player.getYRot(), this.player.getXRot()); // CraftBukkit
+                    this.player.absMoveTo( d3, d4, d5, this.player.getYRot(), this.player.getXRot() ); // Forge - Resync player position on vehicle moving
+                    this.connection.send( new ClientboundMoveVehiclePacket( entity ) );
+                    return;
+                }
+
+                // CraftBukkit start - fire PlayerMoveEvent
+                org.bukkit.entity.Player player = this.getCraftPlayer();
+                // Spigot Start
+                if ( !hasMoved )
+                {
+                    lastPosX = curPos.getX();
+                    lastPosY = curPos.getY();
+                    lastPosZ = curPos.getZ();
+                    lastYaw = curPos.getYaw();
+                    lastPitch = curPos.getPitch();
+                    hasMoved = true;
+                }
+                // Spigot End
+                org.bukkit.Location from = new org.bukkit.Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch); // Get the Players previous org.bukkit.event.Event location.
+                org.bukkit.Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
+
+                // If the packet contains movement information then we update the To location with the correct XYZ.
+                to.setX(p_9876_.getX());
+                to.setY(p_9876_.getY());
+                to.setZ(p_9876_.getZ());
+
+                // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
+                to.setYaw(p_9876_.getYRot());
+                to.setPitch(p_9876_.getXRot());
+
+                // Prevent 40 event-calls for less than a single pixel of movement >.>
+                double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
+                float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
+
+                if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isImmobile()) {
+                    this.lastPosX = to.getX();
+                    this.lastPosY = to.getY();
+                    this.lastPosZ = to.getZ();
+                    this.lastYaw = to.getYaw();
+                    this.lastPitch = to.getPitch();
+
+                    // Skip the first time we do this
+                    if (true) { // Spigot - don't skip any move events
+                        org.bukkit.Location oldTo = to.clone();
+                        org.bukkit.event.player.PlayerMoveEvent event = new org.bukkit.event.player.PlayerMoveEvent(player, from, to);
+                        this.cserver.getPluginManager().callEvent(event);
+
+                        // If the event is cancelled we move the player back to their old location.
+                        if (event.isCancelled()) {
+                            teleport(from);
+                            return;
+                        }
+
+                        // If a Plugin has changed the To destination then we teleport the Player
+                        // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
+                        // We only do this if the org.bukkit.event.Event was not cancelled.
+                        if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
+                            this.player.getBukkitEntity().teleport(event.getTo(), org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.PLUGIN);
+                            return;
+                        }
+
+                        // Check to see if the Players org.bukkit.Location has some how changed during the call of the event.
+                        // This can happen due to a plugin teleporting the player instead of using .setTo()
+                        if (!from.equals(this.getCraftPlayer().getLocation()) && this.justTeleported) {
+                            this.justTeleported = false;
+                            return;
+                        }
+                    }
+                }
+                // CraftBukkit end
+
+                this.player.getLevel().getChunkSource().move( this.player );
+                this.player.checkMovementStatistics( this.player.getX() - d0, this.player.getY() - d1, this.player.getZ() - d2 );
+                this.clientVehicleIsFloating = d7 >= -0.03125D && !flag1 && !this.server.isFlightAllowed() && !entity.isNoGravity() && this.noBlocksAround( entity );
+                this.vehicleLastGoodX = entity.getX();
+                this.vehicleLastGoodY = entity.getY();
+                this.vehicleLastGoodZ = entity.getZ();
+            }
+
+        }
+    }
+
+    private boolean noBlocksAround(Entity p_9794_) {
+        return BlockPos.betweenClosedStream( p_9794_.getBoundingBox().inflate( 0.0625D ).expandTowards( 0.0D, -0.55D, 0.0D ) ).allMatch( b -> p_9794_.level.getBlockState( b ).isAir() );
+    }
+
+    public void handleAcceptTeleportPacket(ServerboundAcceptTeleportationPacket p_9835_) {
+        PacketUtils.ensureRunningOnSameThread( p_9835_, this, this.player.getLevel() );
+        if (p_9835_.getId() == this.awaitingTeleport && this.awaitingPositionFromClient != null) { // CraftBukkit
+            this.player.absMoveTo( this.awaitingPositionFromClient.x, this.awaitingPositionFromClient.y, this.awaitingPositionFromClient.z, this.player.getYRot(), this.player.getXRot() );
+            this.lastGoodX = this.awaitingPositionFromClient.x;
+            this.lastGoodY = this.awaitingPositionFromClient.y;
+            this.lastGoodZ = this.awaitingPositionFromClient.z;
+            if (this.player.isChangingDimension()) {
+                this.player.hasChangedDimension();
+            }
+
+            this.awaitingPositionFromClient = null;
+            if (this.player.valid) //Magma
+                this.player.getLevel().getChunkSource().move(this.player); // CraftBukkit
+        }
+
+    }
+
+    public void handleRecipeBookSeenRecipePacket(ServerboundRecipeBookSeenRecipePacket p_9897_) {
+        PacketUtils.ensureRunningOnSameThread( p_9897_, this, this.player.getLevel() );
+        this.server.getRecipeManager().byKey( p_9897_.getRecipe() ).ifPresent( this.player.getRecipeBook()::removeHighlight );
+    }
+
+    public void handleRecipeBookChangeSettingsPacket(ServerboundRecipeBookChangeSettingsPacket p_9895_) {
+        PacketUtils.ensureRunningOnSameThread( p_9895_, this, this.player.getLevel() );
+        this.player.getRecipeBook().setBookSetting( p_9895_.getBookType(), p_9895_.isOpen(), p_9895_.isFiltering() );
+    }
+
+    public void handleSeenAdvancements(ServerboundSeenAdvancementsPacket p_9903_) {
+        PacketUtils.ensureRunningOnSameThread( p_9903_, this, this.player.getLevel() );
+        if (p_9903_.getAction() == ServerboundSeenAdvancementsPacket.Action.OPENED_TAB) {
+            ResourceLocation resourcelocation = p_9903_.getTab();
+            Advancement advancement = this.server.getAdvancements().getAdvancement( resourcelocation );
+            if (advancement != null) {
+                this.player.getAdvancements().setSelectedTab( advancement );
+            }
+        }
+
+    }
+
+    public void handleCustomCommandSuggestions(ServerboundCommandSuggestionPacket p_9847_) {
+        PacketUtils.ensureRunningOnSameThread( p_9847_, this, this.player.getLevel() );
+        // CraftBukkit start
+        this.chatSpamTickCount += 1;
+        if (chatSpamTickCount > 500 && !this.server.getPlayerList().isOp(this.player.getGameProfile())) {
+            this.disconnect(new TranslatableComponent("disconnect.spam", new Object[0]));
+            return;
+        }
+        // CraftBukkit end
+        StringReader stringreader = new StringReader( p_9847_.getCommand() );
+        if (stringreader.canRead() && stringreader.peek() == '/') {
+            stringreader.skip();
+        }
+
+        ParseResults<CommandSourceStack> parseresults = this.server.getCommands().getDispatcher().parse( stringreader, this.player.createCommandSourceStack() );
+        this.server.getCommands().getDispatcher().getCompletionSuggestions( parseresults ).thenAccept( (p_143647_) -> {
+            if (p_143647_.isEmpty()) return; // CraftBukkit - don't send through empty suggestions - prevents [<args>] from showing for plugins with nothing more to offer
+            this.connection.send( new ClientboundCommandSuggestionsPacket( p_9847_.getId(), p_143647_ ) );
+        } );
+    }
+
+    public void handleSetCommandBlock(ServerboundSetCommandBlockPacket p_9911_) {
+        PacketUtils.ensureRunningOnSameThread( p_9911_, this, this.player.getLevel() );
+        if (!this.server.isCommandBlockEnabled()) {
+            this.player.sendMessage( new TranslatableComponent( "advMode.notEnabled" ), Util.NIL_UUID );
+        } else if (!this.player.canUseGameMasterBlocks()) {
+            this.player.sendMessage( new TranslatableComponent( "advMode.notAllowed" ), Util.NIL_UUID );
+        } else {
+            BaseCommandBlock basecommandblock = null;
+            CommandBlockEntity commandblockentity = null;
+            BlockPos blockpos = p_9911_.getPos();
+            BlockEntity blockentity = this.player.level.getBlockEntity( blockpos );
+            if (blockentity instanceof CommandBlockEntity) {
+                commandblockentity = (CommandBlockEntity) blockentity;
+                basecommandblock = commandblockentity.getCommandBlock();
+            }
+
+            String s = p_9911_.getCommand();
+            boolean flag = p_9911_.isTrackOutput();
+            if (basecommandblock != null) {
+                CommandBlockEntity.Mode commandblockentity$mode = commandblockentity.getMode();
+                BlockState blockstate = this.player.level.getBlockState( blockpos );
+                Direction direction = blockstate.getValue( CommandBlock.FACING );
+                BlockState blockstate1;
+                switch (p_9911_.getMode()) {
+                    case SEQUENCE:
+                        blockstate1 = Blocks.CHAIN_COMMAND_BLOCK.defaultBlockState();
+                        break;
+                    case AUTO:
+                        blockstate1 = Blocks.REPEATING_COMMAND_BLOCK.defaultBlockState();
+                        break;
+                    case REDSTONE:
+                    default:
+                        blockstate1 = Blocks.COMMAND_BLOCK.defaultBlockState();
+                }
+
+                BlockState blockstate2 = blockstate1.setValue( CommandBlock.FACING, direction ).setValue( CommandBlock.CONDITIONAL, Boolean.valueOf( p_9911_.isConditional() ) );
+                if (blockstate2 != blockstate) {
+                    this.player.level.setBlock( blockpos, blockstate2, 2 );
+                    blockentity.setBlockState( blockstate2 );
+                    this.player.level.getChunkAt( blockpos ).setBlockEntity( blockentity );
+                }
+
+                basecommandblock.setCommand( s );
+                basecommandblock.setTrackOutput( flag );
+                if (!flag) {
+                    basecommandblock.setLastOutput( (Component) null );
+                }
+
+                commandblockentity.setAutomatic( p_9911_.isAutomatic() );
+                if (commandblockentity$mode != p_9911_.getMode()) {
+                    commandblockentity.onModeSwitch();
+                }
+
+                basecommandblock.onUpdated();
+                if (!StringUtil.isNullOrEmpty( s )) {
+                    this.player.sendMessage( new TranslatableComponent( "advMode.setCommand.success", s ), Util.NIL_UUID );
+                }
+            }
+
+        }
+    }
+
+    public void handleSetCommandMinecart(ServerboundSetCommandMinecartPacket p_9913_) {
+        PacketUtils.ensureRunningOnSameThread( p_9913_, this, this.player.getLevel() );
+        if (!this.server.isCommandBlockEnabled()) {
+            this.player.sendMessage( new TranslatableComponent( "advMode.notEnabled" ), Util.NIL_UUID );
+        } else if (!this.player.canUseGameMasterBlocks()) {
+            this.player.sendMessage( new TranslatableComponent( "advMode.notAllowed" ), Util.NIL_UUID );
+        } else {
+            BaseCommandBlock basecommandblock = p_9913_.getCommandBlock( this.player.level );
+            if (basecommandblock != null) {
+                basecommandblock.setCommand( p_9913_.getCommand() );
+                basecommandblock.setTrackOutput( p_9913_.isTrackOutput() );
+                if (!p_9913_.isTrackOutput()) {
+                    basecommandblock.setLastOutput( (Component) null );
+                }
+
+                basecommandblock.onUpdated();
+                this.player.sendMessage( new TranslatableComponent( "advMode.setCommand.success", p_9913_.getCommand() ), Util.NIL_UUID );
+            }
+
+        }
+    }
+
+    public void handlePickItem(ServerboundPickItemPacket p_9880_) {
+        PacketUtils.ensureRunningOnSameThread( p_9880_, this, this.player.getLevel() );
+        this.player.getInventory().pickSlot( p_9880_.getSlot() );
+        this.player.connection.send( new ClientboundContainerSetSlotPacket( -2, 0, this.player.getInventory().selected, this.player.getInventory().getItem( this.player.getInventory().selected ) ) );
+        this.player.connection.send( new ClientboundContainerSetSlotPacket( -2, 0, p_9880_.getSlot(), this.player.getInventory().getItem( p_9880_.getSlot() ) ) );
+        this.player.connection.send( new ClientboundSetCarriedItemPacket( this.player.getInventory().selected ) );
+    }
+
+    public void handleRenameItem(ServerboundRenameItemPacket p_9899_) {
+        PacketUtils.ensureRunningOnSameThread( p_9899_, this, this.player.getLevel() );
+        if (this.player.containerMenu instanceof AnvilMenu) {
+            AnvilMenu anvilmenu = (AnvilMenu) this.player.containerMenu;
+            String s = SharedConstants.filterText( p_9899_.getName() );
+            if (s.length() <= 50) {
+                anvilmenu.setItemName( s );
+            }
+        }
+
+    }
+
+    public void handleSetBeaconPacket(ServerboundSetBeaconPacket p_9907_) {
+        PacketUtils.ensureRunningOnSameThread( p_9907_, this, this.player.getLevel() );
+        if (this.player.containerMenu instanceof BeaconMenu) {
+            ((BeaconMenu) this.player.containerMenu).updateEffects( p_9907_.getPrimary(), p_9907_.getSecondary() );
+        }
+
+    }
+
+    public void handleSetStructureBlock(ServerboundSetStructureBlockPacket p_9919_) {
+        PacketUtils.ensureRunningOnSameThread( p_9919_, this, this.player.getLevel() );
+        if (this.player.canUseGameMasterBlocks()) {
+            BlockPos blockpos = p_9919_.getPos();
+            BlockState blockstate = this.player.level.getBlockState( blockpos );
+            BlockEntity blockentity = this.player.level.getBlockEntity( blockpos );
+            if (blockentity instanceof StructureBlockEntity) {
+                StructureBlockEntity structureblockentity = (StructureBlockEntity) blockentity;
+                structureblockentity.setMode( p_9919_.getMode() );
+                structureblockentity.setStructureName( p_9919_.getName() );
+                structureblockentity.setStructurePos( p_9919_.getOffset() );
+                structureblockentity.setStructureSize( p_9919_.getSize() );
+                structureblockentity.setMirror( p_9919_.getMirror() );
+                structureblockentity.setRotation( p_9919_.getRotation() );
+                structureblockentity.setMetaData( p_9919_.getData() );
+                structureblockentity.setIgnoreEntities( p_9919_.isIgnoreEntities() );
+                structureblockentity.setShowAir( p_9919_.isShowAir() );
+                structureblockentity.setShowBoundingBox( p_9919_.isShowBoundingBox() );
+                structureblockentity.setIntegrity( p_9919_.getIntegrity() );
+                structureblockentity.setSeed( p_9919_.getSeed() );
+                if (structureblockentity.hasStructureName()) {
+                    String s = structureblockentity.getStructureName();
+                    if (p_9919_.getUpdateType() == StructureBlockEntity.UpdateType.SAVE_AREA) {
+                        if (structureblockentity.saveStructure()) {
+                            this.player.displayClientMessage( new TranslatableComponent( "structure_block.save_success", s ), false );
+                        } else {
+                            this.player.displayClientMessage( new TranslatableComponent( "structure_block.save_failure", s ), false );
+                        }
+                    } else if (p_9919_.getUpdateType() == StructureBlockEntity.UpdateType.LOAD_AREA) {
+                        if (!structureblockentity.isStructureLoadable()) {
+                            this.player.displayClientMessage( new TranslatableComponent( "structure_block.load_not_found", s ), false );
+                        } else if (structureblockentity.loadStructure( this.player.getLevel() )) {
+                            this.player.displayClientMessage( new TranslatableComponent( "structure_block.load_success", s ), false );
+                        } else {
+                            this.player.displayClientMessage( new TranslatableComponent( "structure_block.load_prepare", s ), false );
+                        }
+                    } else if (p_9919_.getUpdateType() == StructureBlockEntity.UpdateType.SCAN_AREA) {
+                        if (structureblockentity.detectSize()) {
+                            this.player.displayClientMessage( new TranslatableComponent( "structure_block.size_success", s ), false );
+                        } else {
+                            this.player.displayClientMessage( new TranslatableComponent( "structure_block.size_failure" ), false );
+                        }
+                    }
+                } else {
+                    this.player.displayClientMessage( new TranslatableComponent( "structure_block.invalid_structure_name", p_9919_.getName() ), false );
+                }
+
+                structureblockentity.setChanged();
+                this.player.level.sendBlockUpdated( blockpos, blockstate, blockstate, 3 );
+            }
+
+        }
+    }
+
+    public void handleSetJigsawBlock(ServerboundSetJigsawBlockPacket p_9917_) {
+        PacketUtils.ensureRunningOnSameThread( p_9917_, this, this.player.getLevel() );
+        if (this.player.canUseGameMasterBlocks()) {
+            BlockPos blockpos = p_9917_.getPos();
+            BlockState blockstate = this.player.level.getBlockState( blockpos );
+            BlockEntity blockentity = this.player.level.getBlockEntity( blockpos );
+            if (blockentity instanceof JigsawBlockEntity) {
+                JigsawBlockEntity jigsawblockentity = (JigsawBlockEntity) blockentity;
+                jigsawblockentity.setName( p_9917_.getName() );
+                jigsawblockentity.setTarget( p_9917_.getTarget() );
+                jigsawblockentity.setPool( p_9917_.getPool() );
+                jigsawblockentity.setFinalState( p_9917_.getFinalState() );
+                jigsawblockentity.setJoint( p_9917_.getJoint() );
+                jigsawblockentity.setChanged();
+                this.player.level.sendBlockUpdated( blockpos, blockstate, blockstate, 3 );
+            }
+
+        }
+    }
+
+    public void handleJigsawGenerate(ServerboundJigsawGeneratePacket p_9868_) {
+        PacketUtils.ensureRunningOnSameThread( p_9868_, this, this.player.getLevel() );
+        if (this.player.canUseGameMasterBlocks()) {
+            BlockPos blockpos = p_9868_.getPos();
+            BlockEntity blockentity = this.player.level.getBlockEntity( blockpos );
+            if (blockentity instanceof JigsawBlockEntity) {
+                JigsawBlockEntity jigsawblockentity = (JigsawBlockEntity) blockentity;
+                jigsawblockentity.generate( this.player.getLevel(), p_9868_.levels(), p_9868_.keepJigsaws() );
+            }
+
+        }
+    }
+
+    public void handleSelectTrade(ServerboundSelectTradePacket p_9905_) {
+        PacketUtils.ensureRunningOnSameThread( p_9905_, this, this.player.getLevel() );
+        int i = p_9905_.getItem();
+        AbstractContainerMenu abstractcontainermenu = this.player.containerMenu;
+        if (abstractcontainermenu instanceof MerchantMenu) {
+            MerchantMenu merchantmenu = (MerchantMenu) abstractcontainermenu;
+
+            // CraftBukkit start
+            final org.bukkit.event.inventory.TradeSelectEvent tradeSelectEvent = org.bukkit.craftbukkit.v1_18_R2.event.CraftEventFactory.callTradeSelectEvent(this.player, i, merchantmenu);
+            if (tradeSelectEvent.isCancelled()) {
+                this.player.getBukkitEntity().updateInventory();
+                return;
+            }
+            // CraftBukkit end
+
+            merchantmenu.setSelectionHint( i );
+            merchantmenu.tryMoveItems( i );
+        }
+
+    }
+
+    public void handleEditBook(ServerboundEditBookPacket p_9862_) {
+        // CraftBukkit start
+        if (this.lastBookTick + 20 > MinecraftServer.currentTick) {
+            this.disconnect("Book edited too quickly!");
+            return;
+        }
+        this.lastBookTick = MinecraftServer.currentTick;
+        // CraftBukkit end
+        int i = p_9862_.getSlot();
+        if (Inventory.isHotbarSlot( i ) || i == 40) {
+            List<String> list = Lists.newArrayList();
+            Optional<String> optional = p_9862_.getTitle();
+            optional.ifPresent( list::add );
+            p_9862_.getPages().stream().limit( 100L ).forEach( list::add );
+            this.filterTextPacket( list, optional.isPresent() ? (p_143657_) -> {
+                this.signBook( p_143657_.get( 0 ), p_143657_.subList( 1, p_143657_.size() ), i );
+            } : (p_143627_) -> {
+                this.updateBookContents( p_143627_, i );
+            } );
+        }
+    }
+
+    private void updateBookContents(List<TextFilter.FilteredText> p_9813_, int p_9814_) {
+        ItemStack itemstack = this.player.getInventory().getItem( p_9814_ );
+        if (itemstack.is( Items.WRITABLE_BOOK )) {
+            this.updateBookPages(p_9813_, UnaryOperator.identity(), itemstack.copy(), p_9814_, itemstack); // CraftBukkit
+        }
+    }
+
+    private void signBook(TextFilter.FilteredText p_143631_, List<TextFilter.FilteredText> p_143632_, int p_143633_) {
+        ItemStack itemstack = this.player.getInventory().getItem( p_143633_ );
+        if (itemstack.is( Items.WRITABLE_BOOK )) {
+            ItemStack itemstack1 = new ItemStack( Items.WRITTEN_BOOK );
+            CompoundTag compoundtag = itemstack.getTag();
+            if (compoundtag != null) {
+                itemstack1.setTag( compoundtag.copy() );
+            }
+
+            itemstack1.addTagElement( "author", StringTag.valueOf( this.player.getName().getString() ) );
+            if (this.player.isTextFilteringEnabled()) {
+                itemstack1.addTagElement( "title", StringTag.valueOf( p_143631_.getFiltered() ) );
+            } else {
+                itemstack1.addTagElement( "filtered_title", StringTag.valueOf( p_143631_.getFiltered() ) );
+                itemstack1.addTagElement( "title", StringTag.valueOf( p_143631_.getRaw() ) );
+            }
+
+            this.updateBookPages( p_143632_, (p_143659_) -> {
+                return Component.Serializer.toJson( new TextComponent( p_143659_ ) );
+            }, itemstack1, p_143633_, itemstack); // CraftBukkit
+            this.player.getInventory().setItem(p_143633_, itemstack); // CraftBukkit - event factory updates the hand book
+        }
+    }
+
+    private void updateBookPages(List<TextFilter.FilteredText> p_143635_, UnaryOperator<String> p_143636_, ItemStack p_143637_, int slot, ItemStack handItem) { // CraftBukkit
+        ListTag listtag = new ListTag();
+        if (this.player.isTextFilteringEnabled()) {
+            p_143635_.stream().map( (p_143640_) -> {
+                return StringTag.valueOf( p_143636_.apply( p_143640_.getFiltered() ) );
+            } ).forEach( listtag::add );
+        } else {
+            CompoundTag compoundtag = new CompoundTag();
+            int i = 0;
+
+            for (int j = p_143635_.size(); i < j; ++i) {
+                TextFilter.FilteredText textfilter$filteredtext = p_143635_.get( i );
+                String s = textfilter$filteredtext.getRaw();
+                listtag.add( StringTag.valueOf( p_143636_.apply( s ) ) );
+                String s1 = textfilter$filteredtext.getFiltered();
+                if (!s.equals( s1 )) {
+                    compoundtag.putString( String.valueOf( i ), p_143636_.apply( s1 ) );
+                }
+            }
+
+            if (!compoundtag.isEmpty()) {
+                p_143637_.addTagElement( "filtered_pages", compoundtag );
+            }
+        }
+
+        p_143637_.addTagElement( "pages", listtag );
+        org.bukkit.craftbukkit.v1_18_R2.event.CraftEventFactory.handleEditBookEvent(player, slot, handItem, p_143637_); // CraftBukkit
+    }
+
+    public void handleEntityTagQuery(ServerboundEntityTagQuery p_9864_) {
+        PacketUtils.ensureRunningOnSameThread( p_9864_, this, this.player.getLevel() );
+        if (this.player.hasPermissions( 2 )) {
+            Entity entity = this.player.getLevel().getEntity( p_9864_.getEntityId() );
+            if (entity != null) {
+                CompoundTag compoundtag = entity.saveWithoutId( new CompoundTag() );
+                this.player.connection.send( new ClientboundTagQueryPacket( p_9864_.getTransactionId(), compoundtag ) );
+            }
+
+        }
+    }
+
+    public void handleBlockEntityTagQuery(ServerboundBlockEntityTagQuery p_9837_) {
+        PacketUtils.ensureRunningOnSameThread( p_9837_, this, this.player.getLevel() );
+        if (this.player.hasPermissions( 2 )) {
+            BlockEntity blockentity = this.player.getLevel().getBlockEntity( p_9837_.getPos() );
+            CompoundTag compoundtag = blockentity != null ? blockentity.saveWithoutMetadata() : null;
+            this.player.connection.send( new ClientboundTagQueryPacket( p_9837_.getTransactionId(), compoundtag ) );
+        }
+    }
+
+    public void handleMovePlayer(ServerboundMovePlayerPacket p_9874_) {
+        PacketUtils.ensureRunningOnSameThread( p_9874_, this, this.player.getLevel() );
+        if (containsInvalidValues( p_9874_.getX( 0.0D ), p_9874_.getY( 0.0D ), p_9874_.getZ( 0.0D ), p_9874_.getYRot( 0.0F ), p_9874_.getXRot( 0.0F ) )) {
+            this.disconnect( new TranslatableComponent( "multiplayer.disconnect.invalid_player_movement" ) );
+        } else {
             ServerLevel serverlevel = this.player.getLevel();
-            double d0 = entity.getX();
-            double d1 = entity.getY();
-            double d2 = entity.getZ();
-            double d3 = clampHorizontal(p_9876_.getX());
-            double d4 = clampVertical(p_9876_.getY());
-            double d5 = clampHorizontal(p_9876_.getZ());
-            float f = Mth.wrapDegrees(p_9876_.getYRot());
-            float f1 = Mth.wrapDegrees(p_9876_.getXRot());
-            double d6 = d3 - this.vehicleFirstGoodX;
-            double d7 = d4 - this.vehicleFirstGoodY;
-            double d8 = d5 - this.vehicleFirstGoodZ;
-            double d9 = entity.getDeltaMovement().lengthSqr();
-            double d10 = d6 * d6 + d7 * d7 + d8 * d8;
-            if (d10 - d9 > 100.0D && !this.isSingleplayerOwner()) {
-               LOGGER.warn("{} (vehicle of {}) moved too quickly! {},{},{}", entity.getName().getString(), this.player.getName().getString(), d6, d7, d8);
-               this.connection.send(new ClientboundMoveVehiclePacket(entity));
-               return;
-            }
-
-            boolean flag = serverlevel.noCollision(entity, entity.getBoundingBox().deflate(0.0625D));
-            d6 = d3 - this.vehicleLastGoodX;
-            d7 = d4 - this.vehicleLastGoodY - 1.0E-6D;
-            d8 = d5 - this.vehicleLastGoodZ;
-            boolean flag1 = entity.verticalCollisionBelow;
-            entity.move(MoverType.PLAYER, new Vec3(d6, d7, d8));
-            d6 = d3 - entity.getX();
-            d7 = d4 - entity.getY();
-            if (d7 > -0.5D || d7 < 0.5D) {
-               d7 = 0.0D;
-            }
-
-            d8 = d5 - entity.getZ();
-            d10 = d6 * d6 + d7 * d7 + d8 * d8;
-            boolean flag2 = false;
-            if (d10 > 0.0625D) {
-               flag2 = true;
-               LOGGER.warn("{} (vehicle of {}) moved wrongly! {}", entity.getName().getString(), this.player.getName().getString(), Math.sqrt(d10));
-            }
-
-            entity.absMoveTo(d3, d4, d5, f, f1);
-            boolean flag3 = serverlevel.noCollision(entity, entity.getBoundingBox().deflate(0.0625D));
-            if (flag && (flag2 || !flag3)) {
-               entity.absMoveTo(d0, d1, d2, f, f1);
-               this.connection.send(new ClientboundMoveVehiclePacket(entity));
-               return;
-            }
-
-            this.player.getLevel().getChunkSource().move(this.player);
-            this.player.checkMovementStatistics(this.player.getX() - d0, this.player.getY() - d1, this.player.getZ() - d2);
-            this.clientVehicleIsFloating = d7 >= -0.03125D && !flag1 && !this.server.isFlightAllowed() && !entity.isNoGravity() && this.noBlocksAround(entity);
-            this.vehicleLastGoodX = entity.getX();
-            this.vehicleLastGoodY = entity.getY();
-            this.vehicleLastGoodZ = entity.getZ();
-         }
-
-      }
-   }
-
-   private boolean noBlocksAround(Entity p_9794_) {
-      return p_9794_.level.getBlockStates(p_9794_.getBoundingBox().inflate(0.0625D).expandTowards(0.0D, -0.55D, 0.0D)).allMatch(BlockBehaviour.BlockStateBase::isAir);
-   }
-
-   public void handleAcceptTeleportPacket(ServerboundAcceptTeleportationPacket p_9835_) {
-      PacketUtils.ensureRunningOnSameThread(p_9835_, this, this.player.getLevel());
-      if (p_9835_.getId() == this.awaitingTeleport) {
-         this.player.absMoveTo(this.awaitingPositionFromClient.x, this.awaitingPositionFromClient.y, this.awaitingPositionFromClient.z, this.player.getYRot(), this.player.getXRot());
-         this.lastGoodX = this.awaitingPositionFromClient.x;
-         this.lastGoodY = this.awaitingPositionFromClient.y;
-         this.lastGoodZ = this.awaitingPositionFromClient.z;
-         if (this.player.isChangingDimension()) {
-            this.player.hasChangedDimension();
-         }
-
-         this.awaitingPositionFromClient = null;
-      }
-
-   }
-
-   public void handleRecipeBookSeenRecipePacket(ServerboundRecipeBookSeenRecipePacket p_9897_) {
-      PacketUtils.ensureRunningOnSameThread(p_9897_, this, this.player.getLevel());
-      this.server.getRecipeManager().byKey(p_9897_.getRecipe()).ifPresent(this.player.getRecipeBook()::removeHighlight);
-   }
-
-   public void handleRecipeBookChangeSettingsPacket(ServerboundRecipeBookChangeSettingsPacket p_9895_) {
-      PacketUtils.ensureRunningOnSameThread(p_9895_, this, this.player.getLevel());
-      this.player.getRecipeBook().setBookSetting(p_9895_.getBookType(), p_9895_.isOpen(), p_9895_.isFiltering());
-   }
-
-   public void handleSeenAdvancements(ServerboundSeenAdvancementsPacket p_9903_) {
-      PacketUtils.ensureRunningOnSameThread(p_9903_, this, this.player.getLevel());
-      if (p_9903_.getAction() == ServerboundSeenAdvancementsPacket.Action.OPENED_TAB) {
-         ResourceLocation resourcelocation = p_9903_.getTab();
-         Advancement advancement = this.server.getAdvancements().getAdvancement(resourcelocation);
-         if (advancement != null) {
-            this.player.getAdvancements().setSelectedTab(advancement);
-         }
-      }
-
-   }
-
-   public void handleCustomCommandSuggestions(ServerboundCommandSuggestionPacket p_9847_) {
-      PacketUtils.ensureRunningOnSameThread(p_9847_, this, this.player.getLevel());
-      StringReader stringreader = new StringReader(p_9847_.getCommand());
-      if (stringreader.canRead() && stringreader.peek() == '/') {
-         stringreader.skip();
-      }
-
-      ParseResults<CommandSourceStack> parseresults = this.server.getCommands().getDispatcher().parse(stringreader, this.player.createCommandSourceStack());
-      this.server.getCommands().getDispatcher().getCompletionSuggestions(parseresults).thenAccept((p_143647_) -> {
-         this.connection.send(new ClientboundCommandSuggestionsPacket(p_9847_.getId(), p_143647_));
-      });
-   }
-
-   public void handleSetCommandBlock(ServerboundSetCommandBlockPacket p_9911_) {
-      PacketUtils.ensureRunningOnSameThread(p_9911_, this, this.player.getLevel());
-      if (!this.server.isCommandBlockEnabled()) {
-         this.player.sendMessage(new TranslatableComponent("advMode.notEnabled"), Util.NIL_UUID);
-      } else if (!this.player.canUseGameMasterBlocks()) {
-         this.player.sendMessage(new TranslatableComponent("advMode.notAllowed"), Util.NIL_UUID);
-      } else {
-         BaseCommandBlock basecommandblock = null;
-         CommandBlockEntity commandblockentity = null;
-         BlockPos blockpos = p_9911_.getPos();
-         BlockEntity blockentity = this.player.level.getBlockEntity(blockpos);
-         if (blockentity instanceof CommandBlockEntity) {
-            commandblockentity = (CommandBlockEntity)blockentity;
-            basecommandblock = commandblockentity.getCommandBlock();
-         }
-
-         String s = p_9911_.getCommand();
-         boolean flag = p_9911_.isTrackOutput();
-         if (basecommandblock != null) {
-            CommandBlockEntity.Mode commandblockentity$mode = commandblockentity.getMode();
-            BlockState blockstate = this.player.level.getBlockState(blockpos);
-            Direction direction = blockstate.getValue(CommandBlock.FACING);
-            BlockState blockstate1;
-            switch(p_9911_.getMode()) {
-            case SEQUENCE:
-               blockstate1 = Blocks.CHAIN_COMMAND_BLOCK.defaultBlockState();
-               break;
-            case AUTO:
-               blockstate1 = Blocks.REPEATING_COMMAND_BLOCK.defaultBlockState();
-               break;
-            case REDSTONE:
+            if (!this.player.wonGame && !this.player.isImmobile()) { // CraftBukkit
+                if (this.tickCount == 0) {
+                    this.resetPosition();
+                }
+
+                if (this.awaitingPositionFromClient != null) {
+                    if (this.tickCount - this.awaitingTeleportTime > 20) {
+                        this.awaitingTeleportTime = this.tickCount;
+                        this.teleport( this.awaitingPositionFromClient.x, this.awaitingPositionFromClient.y, this.awaitingPositionFromClient.z, this.player.getYRot(), this.player.getXRot() );
+                    }
+
+                    this.allowedPlayerTicks = 20; // CraftBukkit
+                } else {
+                    this.awaitingTeleportTime = this.tickCount;
+                    double d0 = clampHorizontal( p_9874_.getX( this.player.getX() ) );
+                    double d1 = clampVertical( p_9874_.getY( this.player.getY() ) );
+                    double d2 = clampHorizontal( p_9874_.getZ( this.player.getZ() ) );
+                    float f = Mth.wrapDegrees( p_9874_.getYRot( this.player.getYRot() ) );
+                    float f1 = Mth.wrapDegrees( p_9874_.getXRot( this.player.getXRot() ) );
+                    if (this.player.isPassenger()) {
+                        this.player.absMoveTo( this.player.getX(), this.player.getY(), this.player.getZ(), f, f1 );
+                        this.player.getLevel().getChunkSource().move( this.player );
+                        this.allowedPlayerTicks = 20; // CraftBukkit
+                    } else {
+                        double d3 = this.player.getX();
+                        double d4 = this.player.getY();
+                        double d5 = this.player.getZ();
+                        double d6 = this.player.getY();
+                        double d7 = d0 - this.firstGoodX;
+                        double d8 = d1 - this.firstGoodY;
+                        double d9 = d2 - this.firstGoodZ;
+                        double d10 = this.player.getDeltaMovement().lengthSqr();
+                        double d11 = d7 * d7 + d8 * d8 + d9 * d9;
+                        // CraftBukkit - Make sure the move is valid but then reset it for plugins to modify
+                        double prevX = player.getX();
+                        double prevY = player.getY();
+                        double prevZ = player.getZ();
+                        float prevYaw = player.getYRot();
+                        float prevPitch = player.getXRot();
+                        // CraftBukkit end
+                        if (this.player.isSleeping()) {
+                            if (d11 > 1.0D) {
+                                this.teleport( this.player.getX(), this.player.getY(), this.player.getZ(), f, f1 );
+                            }
+
+                        } else {
+                            ++this.receivedMovePacketCount;
+                            int i = this.receivedMovePacketCount - this.knownMovePacketCount;
+
+                            // CraftBukkit start - handle custom speeds and skipped ticks
+                            this.allowedPlayerTicks += (System.currentTimeMillis() / 50) - this.lastTick;
+                            this.allowedPlayerTicks = Math.max(this.allowedPlayerTicks, 1);
+                            this.lastTick = (int) (System.currentTimeMillis() / 50);
+                            if (i > Math.max(this.allowedPlayerTicks, 5)) {
+                                LOGGER.debug( "{} is sending move packets too frequently ({} packets since last tick)", this.player.getName().getString(), i );
+                                i = 1;
+                            }
+
+                            if (p_9874_.hasRot || d11 > 0) {
+                                allowedPlayerTicks -= 1;
+                            } else {
+                                allowedPlayerTicks = 20;
+                            }
+                            double speed;
+                            if (player.getAbilities().flying) {
+                                speed = player.getAbilities().flyingSpeed * 20f;
+                            } else {
+                                speed = player.getAbilities().walkingSpeed * 10f;
+                            }
+
+                            if (!this.player.isChangingDimension() && (!this.player.getLevel().getGameRules().getBoolean( GameRules.RULE_DISABLE_ELYTRA_MOVEMENT_CHECK ) || !this.player.isFallFlying())) {
+                                float f2 = this.player.isFallFlying() ? 300.0F : 100.0F;
+                                if (d11 - d10 > Math.max(f2, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && !this.isSingleplayerOwner()) {                                    // CraftBukkit end
+                                    LOGGER.warn( "{} moved too quickly! {},{},{}", this.player.getName().getString(), d7, d8, d9 );
+                                    this.teleport( this.player.getX(), this.player.getY(), this.player.getZ(), this.player.getYRot(), this.player.getXRot() );
+                                    return;
+                                }
+                            }
+
+                            AABB aabb = this.player.getBoundingBox();
+                            d7 = d0 - this.lastGoodX;
+                            d8 = d1 - this.lastGoodY;
+                            d9 = d2 - this.lastGoodZ;
+                            boolean flag = d8 > 0.0D;
+                            if (this.player.isOnGround() && !p_9874_.isOnGround() && flag) {
+                                this.player.jumpFromGround();
+                            }
+
+                            boolean flag1 = this.player.verticalCollisionBelow;
+                            this.player.move( MoverType.PLAYER, new Vec3( d7, d8, d9 ) );
+                            this.player.onGround = p_9874_.isOnGround(); // CraftBukkit - SPIGOT-5810, SPIGOT-5835, SPIGOT-6828: reset by this.player.move
+                            d7 = d0 - this.player.getX();
+                            d8 = d1 - this.player.getY();
+                            if (d8 > -0.5D || d8 < 0.5D) {
+                                d8 = 0.0D;
+                            }
+
+                            d9 = d2 - this.player.getZ();
+                            d11 = d7 * d7 + d8 * d8 + d9 * d9;
+                            boolean flag2 = false;
+                            if (!this.player.isChangingDimension() && d11 > org.spigotmc.SpigotConfig.movedWronglyThreshold && !this.player.isSleeping() && !this.player.gameMode.isCreative() && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR) { // Spigot
+                                flag2 = true;
+                                LOGGER.warn( "{} moved wrongly!", (Object) this.player.getName().getString() );
+                            }
+
+                            this.player.absMoveTo( d0, d1, d2, f, f1 );
+                            if (this.player.noPhysics || this.player.isSleeping() || (!flag2 || !serverlevel.noCollision( this.player, aabb )) && !this.isPlayerCollidingWithAnythingNew( serverlevel, aabb )) {
+                                // CraftBukkit start - fire PlayerMoveEvent
+                                // Rest to old location first
+                                this.player.absMoveTo(prevX, prevY, prevZ, prevYaw, prevPitch);
+
+                                org.bukkit.entity.Player player = this.getCraftPlayer();
+                                org.bukkit.Location from = new org.bukkit.Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch); // Get the Players previous org.bukkit.event.Event location.
+                                org.bukkit.Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
+
+                                // If the packet contains movement information then we update the To location with the correct XYZ.
+                                if (p_9874_.hasPos) {
+                                    to.setX(p_9874_.x);
+                                    to.setY(p_9874_.y);
+                                    to.setZ(p_9874_.z);
+                                }
+
+                                // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
+                                if (p_9874_.hasRot) {
+                                    to.setYaw(p_9874_.yRot);
+                                    to.setPitch(p_9874_.xRot);
+                                }
+
+                                // Prevent 40 event-calls for less than a single pixel of movement >.>
+                                double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
+                                float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
+
+                                if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isImmobile()) {
+                                    this.lastPosX = to.getX();
+                                    this.lastPosY = to.getY();
+                                    this.lastPosZ = to.getZ();
+                                    this.lastYaw = to.getYaw();
+                                    this.lastPitch = to.getPitch();
+
+                                    // Skip the first time we do this
+                                    if (from.getX() != Double.MAX_VALUE) {
+                                        org.bukkit.Location oldTo = to.clone();
+                                        org.bukkit.event.player.PlayerMoveEvent event = new org.bukkit.event.player.PlayerMoveEvent(player, from, to);
+                                        this.cserver.getPluginManager().callEvent(event);
+
+                                        // If the event is cancelled we move the player back to their old location.
+                                        if (event.isCancelled()) {
+                                            teleport(from);
+                                            return;
+                                        }
+
+                                        // If a Plugin has changed the To destination then we teleport the Player
+                                        // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
+                                        // We only do this if the org.bukkit.event.Event was not cancelled.
+                                        if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
+                                            this.player.getBukkitEntity().teleport(event.getTo(), org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.PLUGIN);
+                                            return;
+                                        }
+
+                                        // Check to see if the Players org.bukkit.Location has some how changed during the call of the event.
+                                        // This can happen due to a plugin teleporting the player instead of using .setTo()
+                                        if (!from.equals(this.getCraftPlayer().getLocation()) && this.justTeleported) {
+                                            this.justTeleported = false;
+                                            return;
+                                        }
+                                    }
+                                }
+                                this.player.absMoveTo(d0, d1, d2, f, f1); // Copied from above
+                                // CraftBukkit end
+
+                                this.clientIsFloating = d8 >= -0.03125D && !flag1 && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR && !this.server.isFlightAllowed() && !this.player.getAbilities().mayfly && !this.player.hasEffect( MobEffects.LEVITATION ) && !this.player.isFallFlying() && !this.player.isAutoSpinAttack() && this.noBlocksAround( this.player );
+                                this.player.getLevel().getChunkSource().move( this.player );
+                                this.player.doCheckFallDamage( this.player.getY() - d6, p_9874_.isOnGround() );
+                                this.player.setOnGround( p_9874_.isOnGround() );
+                                if (flag) {
+                                    this.player.resetFallDistance();
+                                }
+
+                                this.player.checkMovementStatistics( this.player.getX() - d3, this.player.getY() - d4, this.player.getZ() - d5 );
+                                this.lastGoodX = this.player.getX();
+                                this.lastGoodY = this.player.getY();
+                                this.lastGoodZ = this.player.getZ();
+                            } else {
+                                this.teleport( d3, d4, d5, f, f1 );
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private boolean isPlayerCollidingWithAnythingNew(LevelReader p_9796_, AABB p_9797_) {
+        Iterable<VoxelShape> iterable = p_9796_.getCollisions( this.player, this.player.getBoundingBox().deflate( (double) 1.0E-5F ) );
+        VoxelShape voxelshape = Shapes.create( p_9797_.deflate( (double) 1.0E-5F ) );
+
+        for (VoxelShape voxelshape1 : iterable) {
+            if (!Shapes.joinIsNotEmpty( voxelshape1, voxelshape, BooleanOp.AND )) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    // CraftBukkit start - Delegate to teleport(org.bukkit.Location)
+    public void dismount(double p_143612_, double p_143613_, double p_143614_, float p_143615_, float p_143616_) {
+        this.dismount( p_143612_, p_143613_, p_143614_, p_143615_, p_143616_, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN );
+    }
+
+    public void dismount(double p_143612_, double p_143613_, double p_143614_, float p_143615_, float p_143616_, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause) {
+        this.prepareTeleport(cause);
+        this.teleport( p_143612_, p_143613_, p_143614_, p_143615_, p_143616_, Collections.emptySet(), true );
+    }
+
+    //Magma start - move bukkit teleport to its own method
+    public void teleport(double p_9775_, double p_9776_, double p_9777_, float p_9778_, float p_9779_) {
+        this.teleport( p_9775_, p_9776_, p_9777_, p_9778_, p_9779_, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN );
+    }
+
+    public void teleport(double d0, double d1, double d2, float f, float f1, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause) {
+        this.prepareTeleport(cause);
+        this.teleport( d0, d1, d2, f, f1, Collections.emptySet(), false );
+    }
+
+
+    public void teleport(double p_9781_, double p_9782_, double p_9783_, float p_9784_, float p_9785_, Set<ClientboundPlayerPositionPacket.RelativeArgument> p_9786_, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause) {
+        this.prepareTeleport(cause);
+        this.teleport( p_9781_, p_9782_, p_9783_, p_9784_, p_9785_, p_9786_, false );
+    }
+
+    public void teleport(double p_9781_, double p_9782_, double p_9783_, float p_9784_, float p_9785_, Set<ClientboundPlayerPositionPacket.RelativeArgument> p_9786_) {
+        resetCause();
+        this.teleport( p_9781_, p_9782_, p_9783_, p_9784_, p_9785_, p_9786_, false );
+    }
+
+    org.bukkit.event.player.PlayerTeleportEvent.TeleportCause teleportCause = org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN;
+
+    public void prepareTeleport(org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause) {
+        teleportCause = cause;
+    }
+
+    public void resetCause() {
+        teleportCause = org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN;
+    }
+
+    private boolean teleportResult = true; //assume that the player teleported successfully
+    public void teleport(double p_143618_, double p_143619_, double p_143620_, float p_143621_, float p_143622_, Set<ClientboundPlayerPositionPacket.RelativeArgument> p_143623_, boolean p_143624_) {
+        org.bukkit.event.player.PlayerTeleportEvent.TeleportCause tmp = teleportCause;
+        resetCause();
+        teleportResult = true;
+
+        org.bukkit.entity.Player player = this.getCraftPlayer();
+        org.bukkit.Location from = player.getLocation();
+
+        double x = p_143618_;
+        double y = p_143619_;
+        double z = p_143620_;
+        float yaw = p_143621_;
+        float pitch = p_143622_;
+
+        org.bukkit.Location to = new org.bukkit.Location( this.getCraftPlayer().getWorld(), x, y, z, yaw, pitch );
+        // SPIGOT-5171: Triggered on join
+        if (from.equals( to )) {
+            this.internalTeleport( p_143618_, p_143619_, p_143620_, p_143621_, p_143622_, p_143623_, p_143624_ );
+            return; // CraftBukkit - Return event status
+        }
+
+        org.bukkit.event.player.PlayerTeleportEvent event = new org.bukkit.event.player.PlayerTeleportEvent( player, from.clone(), to.clone(), tmp );
+        this.cserver.getPluginManager().callEvent( event );
+
+        if (event.isCancelled() || !to.equals( event.getTo() )) {
+            p_143623_.clear(); // Can't relative teleport
+            to = event.isCancelled() ? event.getFrom() : event.getTo();
+            p_143618_ = to.getX();
+            p_143619_ = to.getY();
+            p_143620_ = to.getZ();
+            p_143621_ = to.getYaw();
+            p_143622_ = to.getPitch();
+        }
+
+        this.internalTeleport( p_143618_, p_143619_, p_143620_, p_143621_, p_143622_, p_143623_, p_143624_ );
+        teleportResult = event.isCancelled(); // CraftBukkit - Return event status //Magma - set to variable
+    }
+
+    public boolean teleport(double p_143618_, double p_143619_, double p_143620_, float p_143621_, float p_143622_, Set<ClientboundPlayerPositionPacket.RelativeArgument> p_143623_, boolean p_143624_, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause) {
+        this.prepareTeleport(cause);
+        this.teleport( p_143618_, p_143619_, p_143620_, p_143621_, p_143622_, p_143623_, p_143624_ );
+        boolean result = teleportResult;
+        teleportResult = true; //reset
+        return result;
+    }
+    //Magma end
+
+    public void internalTeleport(double p_143618_, double p_143619_, double p_143620_, float p_143621_, float p_143622_, Set<ClientboundPlayerPositionPacket.RelativeArgument> p_143623_, boolean p_143624_) {
+        //CraftBukkit start
+        if (Float.isNaN( p_143621_ )) {
+            p_143621_ = 0;
+        }
+
+        if (Float.isNaN( p_143622_ )) {
+            p_143622_ = 0;
+        }
+
+        this.justTeleported = true;
+        double d0 = p_143623_.contains( ClientboundPlayerPositionPacket.RelativeArgument.X ) ? this.player.getX() : 0.0D;
+        double d1 = p_143623_.contains( ClientboundPlayerPositionPacket.RelativeArgument.Y ) ? this.player.getY() : 0.0D;
+        double d2 = p_143623_.contains( ClientboundPlayerPositionPacket.RelativeArgument.Z ) ? this.player.getZ() : 0.0D;
+        float f = p_143623_.contains( ClientboundPlayerPositionPacket.RelativeArgument.Y_ROT ) ? this.player.getYRot() : 0.0F;
+        float f1 = p_143623_.contains( ClientboundPlayerPositionPacket.RelativeArgument.X_ROT ) ? this.player.getXRot() : 0.0F;
+        this.awaitingPositionFromClient = new Vec3( p_143618_, p_143619_, p_143620_ );
+        if (++this.awaitingTeleport == Integer.MAX_VALUE) {
+            this.awaitingTeleport = 0;
+        }
+
+        // CraftBukkit start - update last location
+        this.lastPosX = this.awaitingPositionFromClient.x;
+        this.lastPosY = this.awaitingPositionFromClient.y;
+        this.lastPosZ = this.awaitingPositionFromClient.z;
+        this.lastYaw = f;
+        this.lastPitch = f1;
+        // CraftBukkit end
+
+        this.awaitingTeleportTime = this.tickCount;
+        this.player.absMoveTo( p_143618_, p_143619_, p_143620_, p_143621_, p_143622_ );
+        this.player.connection.send( new ClientboundPlayerPositionPacket( p_143618_ - d0, p_143619_ - d1, p_143620_ - d2, p_143621_ - f, p_143622_ - f1, p_143623_, this.awaitingTeleport, p_143624_ ) );
+    }
+
+    public void handlePlayerAction(ServerboundPlayerActionPacket p_9889_) {
+        PacketUtils.ensureRunningOnSameThread( p_9889_, this, this.player.getLevel() );
+        if (this.player.isImmobile()) return; // CraftBukkit
+        BlockPos blockpos = p_9889_.getPos();
+        this.player.resetLastActionTime();
+        ServerboundPlayerActionPacket.Action serverboundplayeractionpacket$action = p_9889_.getAction();
+        switch (serverboundplayeractionpacket$action) {
+            case SWAP_ITEM_WITH_OFFHAND:
+                if (!this.player.isSpectator()) {
+                    ItemStack itemstack = this.player.getItemInHand( InteractionHand.OFF_HAND );
+                    // CraftBukkit start - inspiration taken from DispenserRegistry (See SpigotCraft#394)
+                    org.bukkit.craftbukkit.v1_18_R2.inventory.CraftItemStack mainHand = org.bukkit.craftbukkit.v1_18_R2.inventory.CraftItemStack.asCraftMirror(itemstack);
+                    org.bukkit.craftbukkit.v1_18_R2.inventory.CraftItemStack offHand = org.bukkit.craftbukkit.v1_18_R2.inventory.CraftItemStack.asCraftMirror(this.player.getItemInHand(InteractionHand.MAIN_HAND));
+                    org.bukkit.event.player.PlayerSwapHandItemsEvent swapItemsEvent = new org.bukkit.event.player.PlayerSwapHandItemsEvent(getCraftPlayer(), mainHand.clone(), offHand.clone());
+                    this.cserver.getPluginManager().callEvent(swapItemsEvent);
+                    if (swapItemsEvent.isCancelled()) {
+                        return;
+                    }
+                    if (swapItemsEvent.getOffHandItem().equals(offHand)) {
+                        this.player.setItemInHand(InteractionHand.OFF_HAND, this.player.getItemInHand(InteractionHand.MAIN_HAND));
+                    } else {
+                        this.player.setItemInHand(InteractionHand.OFF_HAND, org.bukkit.craftbukkit.v1_18_R2.inventory.CraftItemStack.asNMSCopy(swapItemsEvent.getOffHandItem()));
+                    }
+                    if (swapItemsEvent.getMainHandItem().equals(mainHand)) {
+                        this.player.setItemInHand(InteractionHand.MAIN_HAND, itemstack);
+                    } else {
+                        this.player.setItemInHand(InteractionHand.MAIN_HAND, org.bukkit.craftbukkit.v1_18_R2.inventory.CraftItemStack.asNMSCopy(swapItemsEvent.getMainHandItem()));
+                    }
+                    // CraftBukkit end
+                    this.player.stopUsingItem();
+                }
+
+                return;
+            case DROP_ITEM:
+                if (!this.player.isSpectator()) {
+                    // limit how quickly items can be dropped
+                    // If the ticks aren't the same then the count starts from 0 and we update the lastDropTick.
+                    if (this.lastDropTick != MinecraftServer.currentTick) {
+                        this.dropCount = 0;
+                        this.lastDropTick = MinecraftServer.currentTick;
+                    } else {
+                        // Else we increment the drop count and check the amount.
+                        this.dropCount++;
+                        if (this.dropCount >= 20) {
+                            LOGGER.warn(this.player.getScoreboardName() + " dropped their items too quickly!");
+                            this.disconnect("You dropped your items too quickly (Hacking?)");
+                            return;
+                        }
+                    }
+                    // CraftBukkit end
+                    this.player.drop(false);
+                }
+
+                return;
+            case DROP_ALL_ITEMS:
+                if (!this.player.isSpectator()) {
+                    this.player.drop( true );
+                }
+
+                return;
+            case RELEASE_USE_ITEM:
+                this.player.releaseUsingItem();
+                return;
+            case START_DESTROY_BLOCK:
+            case ABORT_DESTROY_BLOCK:
+            case STOP_DESTROY_BLOCK:
+                this.player.gameMode.handleBlockBreakAction( blockpos, serverboundplayeractionpacket$action, p_9889_.getDirection(), this.player.level.getMaxBuildHeight() );
+                return;
             default:
-               blockstate1 = Blocks.COMMAND_BLOCK.defaultBlockState();
-            }
-
-            BlockState blockstate2 = blockstate1.setValue(CommandBlock.FACING, direction).setValue(CommandBlock.CONDITIONAL, Boolean.valueOf(p_9911_.isConditional()));
-            if (blockstate2 != blockstate) {
-               this.player.level.setBlock(blockpos, blockstate2, 2);
-               blockentity.setBlockState(blockstate2);
-               this.player.level.getChunkAt(blockpos).setBlockEntity(blockentity);
-            }
-
-            basecommandblock.setCommand(s);
-            basecommandblock.setTrackOutput(flag);
-            if (!flag) {
-               basecommandblock.setLastOutput((Component)null);
-            }
-
-            commandblockentity.setAutomatic(p_9911_.isAutomatic());
-            if (commandblockentity$mode != p_9911_.getMode()) {
-               commandblockentity.onModeSwitch();
-            }
-
-            basecommandblock.onUpdated();
-            if (!StringUtil.isNullOrEmpty(s)) {
-               this.player.sendMessage(new TranslatableComponent("advMode.setCommand.success", s), Util.NIL_UUID);
-            }
-         }
-
-      }
-   }
-
-   public void handleSetCommandMinecart(ServerboundSetCommandMinecartPacket p_9913_) {
-      PacketUtils.ensureRunningOnSameThread(p_9913_, this, this.player.getLevel());
-      if (!this.server.isCommandBlockEnabled()) {
-         this.player.sendMessage(new TranslatableComponent("advMode.notEnabled"), Util.NIL_UUID);
-      } else if (!this.player.canUseGameMasterBlocks()) {
-         this.player.sendMessage(new TranslatableComponent("advMode.notAllowed"), Util.NIL_UUID);
-      } else {
-         BaseCommandBlock basecommandblock = p_9913_.getCommandBlock(this.player.level);
-         if (basecommandblock != null) {
-            basecommandblock.setCommand(p_9913_.getCommand());
-            basecommandblock.setTrackOutput(p_9913_.isTrackOutput());
-            if (!p_9913_.isTrackOutput()) {
-               basecommandblock.setLastOutput((Component)null);
-            }
-
-            basecommandblock.onUpdated();
-            this.player.sendMessage(new TranslatableComponent("advMode.setCommand.success", p_9913_.getCommand()), Util.NIL_UUID);
-         }
-
-      }
-   }
-
-   public void handlePickItem(ServerboundPickItemPacket p_9880_) {
-      PacketUtils.ensureRunningOnSameThread(p_9880_, this, this.player.getLevel());
-      this.player.getInventory().pickSlot(p_9880_.getSlot());
-      this.player.connection.send(new ClientboundContainerSetSlotPacket(-2, 0, this.player.getInventory().selected, this.player.getInventory().getItem(this.player.getInventory().selected)));
-      this.player.connection.send(new ClientboundContainerSetSlotPacket(-2, 0, p_9880_.getSlot(), this.player.getInventory().getItem(p_9880_.getSlot())));
-      this.player.connection.send(new ClientboundSetCarriedItemPacket(this.player.getInventory().selected));
-   }
-
-   public void handleRenameItem(ServerboundRenameItemPacket p_9899_) {
-      PacketUtils.ensureRunningOnSameThread(p_9899_, this, this.player.getLevel());
-      if (this.player.containerMenu instanceof AnvilMenu) {
-         AnvilMenu anvilmenu = (AnvilMenu)this.player.containerMenu;
-         String s = SharedConstants.filterText(p_9899_.getName());
-         if (s.length() <= 50) {
-            anvilmenu.setItemName(s);
-         }
-      }
-
-   }
-
-   public void handleSetBeaconPacket(ServerboundSetBeaconPacket p_9907_) {
-      PacketUtils.ensureRunningOnSameThread(p_9907_, this, this.player.getLevel());
-      if (this.player.containerMenu instanceof BeaconMenu) {
-         ((BeaconMenu)this.player.containerMenu).updateEffects(p_9907_.getPrimary(), p_9907_.getSecondary());
-      }
-
-   }
-
-   public void handleSetStructureBlock(ServerboundSetStructureBlockPacket p_9919_) {
-      PacketUtils.ensureRunningOnSameThread(p_9919_, this, this.player.getLevel());
-      if (this.player.canUseGameMasterBlocks()) {
-         BlockPos blockpos = p_9919_.getPos();
-         BlockState blockstate = this.player.level.getBlockState(blockpos);
-         BlockEntity blockentity = this.player.level.getBlockEntity(blockpos);
-         if (blockentity instanceof StructureBlockEntity) {
-            StructureBlockEntity structureblockentity = (StructureBlockEntity)blockentity;
-            structureblockentity.setMode(p_9919_.getMode());
-            structureblockentity.setStructureName(p_9919_.getName());
-            structureblockentity.setStructurePos(p_9919_.getOffset());
-            structureblockentity.setStructureSize(p_9919_.getSize());
-            structureblockentity.setMirror(p_9919_.getMirror());
-            structureblockentity.setRotation(p_9919_.getRotation());
-            structureblockentity.setMetaData(p_9919_.getData());
-            structureblockentity.setIgnoreEntities(p_9919_.isIgnoreEntities());
-            structureblockentity.setShowAir(p_9919_.isShowAir());
-            structureblockentity.setShowBoundingBox(p_9919_.isShowBoundingBox());
-            structureblockentity.setIntegrity(p_9919_.getIntegrity());
-            structureblockentity.setSeed(p_9919_.getSeed());
-            if (structureblockentity.hasStructureName()) {
-               String s = structureblockentity.getStructureName();
-               if (p_9919_.getUpdateType() == StructureBlockEntity.UpdateType.SAVE_AREA) {
-                  if (structureblockentity.saveStructure()) {
-                     this.player.displayClientMessage(new TranslatableComponent("structure_block.save_success", s), false);
-                  } else {
-                     this.player.displayClientMessage(new TranslatableComponent("structure_block.save_failure", s), false);
-                  }
-               } else if (p_9919_.getUpdateType() == StructureBlockEntity.UpdateType.LOAD_AREA) {
-                  if (!structureblockentity.isStructureLoadable()) {
-                     this.player.displayClientMessage(new TranslatableComponent("structure_block.load_not_found", s), false);
-                  } else if (structureblockentity.loadStructure(this.player.getLevel())) {
-                     this.player.displayClientMessage(new TranslatableComponent("structure_block.load_success", s), false);
-                  } else {
-                     this.player.displayClientMessage(new TranslatableComponent("structure_block.load_prepare", s), false);
-                  }
-               } else if (p_9919_.getUpdateType() == StructureBlockEntity.UpdateType.SCAN_AREA) {
-                  if (structureblockentity.detectSize()) {
-                     this.player.displayClientMessage(new TranslatableComponent("structure_block.size_success", s), false);
-                  } else {
-                     this.player.displayClientMessage(new TranslatableComponent("structure_block.size_failure"), false);
-                  }
-               }
-            } else {
-               this.player.displayClientMessage(new TranslatableComponent("structure_block.invalid_structure_name", p_9919_.getName()), false);
-            }
-
-            structureblockentity.setChanged();
-            this.player.level.sendBlockUpdated(blockpos, blockstate, blockstate, 3);
-         }
-
-      }
-   }
-
-   public void handleSetJigsawBlock(ServerboundSetJigsawBlockPacket p_9917_) {
-      PacketUtils.ensureRunningOnSameThread(p_9917_, this, this.player.getLevel());
-      if (this.player.canUseGameMasterBlocks()) {
-         BlockPos blockpos = p_9917_.getPos();
-         BlockState blockstate = this.player.level.getBlockState(blockpos);
-         BlockEntity blockentity = this.player.level.getBlockEntity(blockpos);
-         if (blockentity instanceof JigsawBlockEntity) {
-            JigsawBlockEntity jigsawblockentity = (JigsawBlockEntity)blockentity;
-            jigsawblockentity.setName(p_9917_.getName());
-            jigsawblockentity.setTarget(p_9917_.getTarget());
-            jigsawblockentity.setPool(p_9917_.getPool());
-            jigsawblockentity.setFinalState(p_9917_.getFinalState());
-            jigsawblockentity.setJoint(p_9917_.getJoint());
-            jigsawblockentity.setChanged();
-            this.player.level.sendBlockUpdated(blockpos, blockstate, blockstate, 3);
-         }
-
-      }
-   }
-
-   public void handleJigsawGenerate(ServerboundJigsawGeneratePacket p_9868_) {
-      PacketUtils.ensureRunningOnSameThread(p_9868_, this, this.player.getLevel());
-      if (this.player.canUseGameMasterBlocks()) {
-         BlockPos blockpos = p_9868_.getPos();
-         BlockEntity blockentity = this.player.level.getBlockEntity(blockpos);
-         if (blockentity instanceof JigsawBlockEntity) {
-            JigsawBlockEntity jigsawblockentity = (JigsawBlockEntity)blockentity;
-            jigsawblockentity.generate(this.player.getLevel(), p_9868_.levels(), p_9868_.keepJigsaws());
-         }
-
-      }
-   }
-
-   public void handleSelectTrade(ServerboundSelectTradePacket p_9905_) {
-      PacketUtils.ensureRunningOnSameThread(p_9905_, this, this.player.getLevel());
-      int i = p_9905_.getItem();
-      AbstractContainerMenu abstractcontainermenu = this.player.containerMenu;
-      if (abstractcontainermenu instanceof MerchantMenu) {
-         MerchantMenu merchantmenu = (MerchantMenu)abstractcontainermenu;
-         merchantmenu.setSelectionHint(i);
-         merchantmenu.tryMoveItems(i);
-      }
-
-   }
-
-   public void handleEditBook(ServerboundEditBookPacket p_9862_) {
-      int i = p_9862_.getSlot();
-      if (Inventory.isHotbarSlot(i) || i == 40) {
-         List<String> list = Lists.newArrayList();
-         Optional<String> optional = p_9862_.getTitle();
-         optional.ifPresent(list::add);
-         p_9862_.getPages().stream().limit(100L).forEach(list::add);
-         this.filterTextPacket(list, optional.isPresent() ? (p_143657_) -> {
-            this.signBook(p_143657_.get(0), p_143657_.subList(1, p_143657_.size()), i);
-         } : (p_143627_) -> {
-            this.updateBookContents(p_143627_, i);
-         });
-      }
-   }
-
-   private void updateBookContents(List<TextFilter.FilteredText> p_9813_, int p_9814_) {
-      ItemStack itemstack = this.player.getInventory().getItem(p_9814_);
-      if (itemstack.is(Items.WRITABLE_BOOK)) {
-         this.updateBookPages(p_9813_, UnaryOperator.identity(), itemstack);
-      }
-   }
-
-   private void signBook(TextFilter.FilteredText p_143631_, List<TextFilter.FilteredText> p_143632_, int p_143633_) {
-      ItemStack itemstack = this.player.getInventory().getItem(p_143633_);
-      if (itemstack.is(Items.WRITABLE_BOOK)) {
-         ItemStack itemstack1 = new ItemStack(Items.WRITTEN_BOOK);
-         CompoundTag compoundtag = itemstack.getTag();
-         if (compoundtag != null) {
-            itemstack1.setTag(compoundtag.copy());
-         }
-
-         itemstack1.addTagElement("author", StringTag.valueOf(this.player.getName().getString()));
-         if (this.player.isTextFilteringEnabled()) {
-            itemstack1.addTagElement("title", StringTag.valueOf(p_143631_.getFiltered()));
-         } else {
-            itemstack1.addTagElement("filtered_title", StringTag.valueOf(p_143631_.getFiltered()));
-            itemstack1.addTagElement("title", StringTag.valueOf(p_143631_.getRaw()));
-         }
-
-         this.updateBookPages(p_143632_, (p_143659_) -> {
-            return Component.Serializer.toJson(new TextComponent(p_143659_));
-         }, itemstack1);
-         this.player.getInventory().setItem(p_143633_, itemstack1);
-      }
-   }
-
-   private void updateBookPages(List<TextFilter.FilteredText> p_143635_, UnaryOperator<String> p_143636_, ItemStack p_143637_) {
-      ListTag listtag = new ListTag();
-      if (this.player.isTextFilteringEnabled()) {
-         p_143635_.stream().map((p_143640_) -> {
-            return StringTag.valueOf(p_143636_.apply(p_143640_.getFiltered()));
-         }).forEach(listtag::add);
-      } else {
-         CompoundTag compoundtag = new CompoundTag();
-         int i = 0;
-
-         for(int j = p_143635_.size(); i < j; ++i) {
-            TextFilter.FilteredText textfilter$filteredtext = p_143635_.get(i);
-            String s = textfilter$filteredtext.getRaw();
-            listtag.add(StringTag.valueOf(p_143636_.apply(s)));
-            String s1 = textfilter$filteredtext.getFiltered();
-            if (!s.equals(s1)) {
-               compoundtag.putString(String.valueOf(i), p_143636_.apply(s1));
-            }
-         }
-
-         if (!compoundtag.isEmpty()) {
-            p_143637_.addTagElement("filtered_pages", compoundtag);
-         }
-      }
-
-      p_143637_.addTagElement("pages", listtag);
-   }
-
-   public void handleEntityTagQuery(ServerboundEntityTagQuery p_9864_) {
-      PacketUtils.ensureRunningOnSameThread(p_9864_, this, this.player.getLevel());
-      if (this.player.hasPermissions(2)) {
-         Entity entity = this.player.getLevel().getEntity(p_9864_.getEntityId());
-         if (entity != null) {
-            CompoundTag compoundtag = entity.saveWithoutId(new CompoundTag());
-            this.player.connection.send(new ClientboundTagQueryPacket(p_9864_.getTransactionId(), compoundtag));
-         }
-
-      }
-   }
-
-   public void handleBlockEntityTagQuery(ServerboundBlockEntityTagQuery p_9837_) {
-      PacketUtils.ensureRunningOnSameThread(p_9837_, this, this.player.getLevel());
-      if (this.player.hasPermissions(2)) {
-         BlockEntity blockentity = this.player.getLevel().getBlockEntity(p_9837_.getPos());
-         CompoundTag compoundtag = blockentity != null ? blockentity.saveWithoutMetadata() : null;
-         this.player.connection.send(new ClientboundTagQueryPacket(p_9837_.getTransactionId(), compoundtag));
-      }
-   }
-
-   public void handleMovePlayer(ServerboundMovePlayerPacket p_9874_) {
-      PacketUtils.ensureRunningOnSameThread(p_9874_, this, this.player.getLevel());
-      if (containsInvalidValues(p_9874_.getX(0.0D), p_9874_.getY(0.0D), p_9874_.getZ(0.0D), p_9874_.getYRot(0.0F), p_9874_.getXRot(0.0F))) {
-         this.disconnect(new TranslatableComponent("multiplayer.disconnect.invalid_player_movement"));
-      } else {
-         ServerLevel serverlevel = this.player.getLevel();
-         if (!this.player.wonGame) {
-            if (this.tickCount == 0) {
-               this.resetPosition();
-            }
-
-            if (this.awaitingPositionFromClient != null) {
-               if (this.tickCount - this.awaitingTeleportTime > 20) {
-                  this.awaitingTeleportTime = this.tickCount;
-                  this.teleport(this.awaitingPositionFromClient.x, this.awaitingPositionFromClient.y, this.awaitingPositionFromClient.z, this.player.getYRot(), this.player.getXRot());
-               }
-
-            } else {
-               this.awaitingTeleportTime = this.tickCount;
-               double d0 = clampHorizontal(p_9874_.getX(this.player.getX()));
-               double d1 = clampVertical(p_9874_.getY(this.player.getY()));
-               double d2 = clampHorizontal(p_9874_.getZ(this.player.getZ()));
-               float f = Mth.wrapDegrees(p_9874_.getYRot(this.player.getYRot()));
-               float f1 = Mth.wrapDegrees(p_9874_.getXRot(this.player.getXRot()));
-               if (this.player.isPassenger()) {
-                  this.player.absMoveTo(this.player.getX(), this.player.getY(), this.player.getZ(), f, f1);
-                  this.player.getLevel().getChunkSource().move(this.player);
-               } else {
-                  double d3 = this.player.getX();
-                  double d4 = this.player.getY();
-                  double d5 = this.player.getZ();
-                  double d6 = this.player.getY();
-                  double d7 = d0 - this.firstGoodX;
-                  double d8 = d1 - this.firstGoodY;
-                  double d9 = d2 - this.firstGoodZ;
-                  double d10 = this.player.getDeltaMovement().lengthSqr();
-                  double d11 = d7 * d7 + d8 * d8 + d9 * d9;
-                  if (this.player.isSleeping()) {
-                     if (d11 > 1.0D) {
-                        this.teleport(this.player.getX(), this.player.getY(), this.player.getZ(), f, f1);
-                     }
-
-                  } else {
-                     ++this.receivedMovePacketCount;
-                     int i = this.receivedMovePacketCount - this.knownMovePacketCount;
-                     if (i > 5) {
-                        LOGGER.debug("{} is sending move packets too frequently ({} packets since last tick)", this.player.getName().getString(), i);
-                        i = 1;
-                     }
-
-                     if (!this.player.isChangingDimension() && (!this.player.getLevel().getGameRules().getBoolean(GameRules.RULE_DISABLE_ELYTRA_MOVEMENT_CHECK) || !this.player.isFallFlying())) {
-                        float f2 = this.player.isFallFlying() ? 300.0F : 100.0F;
-                        if (d11 - d10 > (double)(f2 * (float)i) && !this.isSingleplayerOwner()) {
-                           LOGGER.warn("{} moved too quickly! {},{},{}", this.player.getName().getString(), d7, d8, d9);
-                           this.teleport(this.player.getX(), this.player.getY(), this.player.getZ(), this.player.getYRot(), this.player.getXRot());
-                           return;
-                        }
-                     }
-
-                     AABB aabb = this.player.getBoundingBox();
-                     d7 = d0 - this.lastGoodX;
-                     d8 = d1 - this.lastGoodY;
-                     d9 = d2 - this.lastGoodZ;
-                     boolean flag = d8 > 0.0D;
-                     if (this.player.isOnGround() && !p_9874_.isOnGround() && flag) {
-                        this.player.jumpFromGround();
-                     }
-
-                     boolean flag1 = this.player.verticalCollisionBelow;
-                     this.player.move(MoverType.PLAYER, new Vec3(d7, d8, d9));
-                     d7 = d0 - this.player.getX();
-                     d8 = d1 - this.player.getY();
-                     if (d8 > -0.5D || d8 < 0.5D) {
-                        d8 = 0.0D;
-                     }
-
-                     d9 = d2 - this.player.getZ();
-                     d11 = d7 * d7 + d8 * d8 + d9 * d9;
-                     boolean flag2 = false;
-                     if (!this.player.isChangingDimension() && d11 > 0.0625D && !this.player.isSleeping() && !this.player.gameMode.isCreative() && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR) {
-                        flag2 = true;
-                        LOGGER.warn("{} moved wrongly!", (Object)this.player.getName().getString());
-                     }
-
-                     this.player.absMoveTo(d0, d1, d2, f, f1);
-                     if (this.player.noPhysics || this.player.isSleeping() || (!flag2 || !serverlevel.noCollision(this.player, aabb)) && !this.isPlayerCollidingWithAnythingNew(serverlevel, aabb)) {
-                        this.clientIsFloating = d8 >= -0.03125D && !flag1 && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR && !this.server.isFlightAllowed() && !this.player.getAbilities().mayfly && !this.player.hasEffect(MobEffects.LEVITATION) && !this.player.isFallFlying() && !this.player.isAutoSpinAttack() && this.noBlocksAround(this.player);
-                        this.player.getLevel().getChunkSource().move(this.player);
-                        this.player.doCheckFallDamage(this.player.getY() - d6, p_9874_.isOnGround());
-                        this.player.setOnGround(p_9874_.isOnGround());
-                        if (flag) {
-                           this.player.resetFallDistance();
-                        }
-
-                        this.player.checkMovementStatistics(this.player.getX() - d3, this.player.getY() - d4, this.player.getZ() - d5);
-                        this.lastGoodX = this.player.getX();
-                        this.lastGoodY = this.player.getY();
-                        this.lastGoodZ = this.player.getZ();
-                     } else {
-                        this.teleport(d3, d4, d5, f, f1);
-                     }
-                  }
-               }
-            }
-         }
-      }
-   }
-
-   private boolean isPlayerCollidingWithAnythingNew(LevelReader p_9796_, AABB p_9797_) {
-      Iterable<VoxelShape> iterable = p_9796_.getCollisions(this.player, this.player.getBoundingBox().deflate((double)1.0E-5F));
-      VoxelShape voxelshape = Shapes.create(p_9797_.deflate((double)1.0E-5F));
-
-      for(VoxelShape voxelshape1 : iterable) {
-         if (!Shapes.joinIsNotEmpty(voxelshape1, voxelshape, BooleanOp.AND)) {
+                throw new IllegalArgumentException( "Invalid player action" );
+        }
+    }
+
+    private static boolean wasBlockPlacementAttempt(ServerPlayer p_9791_, ItemStack p_9792_) {
+        if (p_9792_.isEmpty()) {
+            return false;
+        } else {
+            Item item = p_9792_.getItem();
+            return (item instanceof BlockItem || item instanceof BucketItem) && !p_9791_.getCooldowns().isOnCooldown( item );
+        }
+    }
+
+    public void handleUseItemOn(ServerboundUseItemOnPacket p_9930_) {
+        PacketUtils.ensureRunningOnSameThread(p_9930_, this, this.player.getLevel());
+        if (this.player.isImmobile()) return; // CraftBukkit
+        if (!checkLimit(p_9930_.timestamp)) return; // Spigot - check limit
+        ServerLevel serverlevel = this.player.getLevel();
+        InteractionHand interactionhand = p_9930_.getHand();
+        ItemStack itemstack = this.player.getItemInHand(interactionhand);
+        BlockHitResult blockhitresult = p_9930_.getHitResult();
+        Vec3 vec3 = blockhitresult.getLocation();
+        BlockPos blockpos = blockhitresult.getBlockPos();
+        Vec3 vec31 = vec3.subtract(Vec3.atCenterOf(blockpos));
+        if (this.player.level.getServer() != null && this.player.chunkPosition().getChessboardDistance(new ChunkPos(blockpos)) < this.player.level.spigotConfig.viewDistance) { // Spigot
+            double d0 = 1.0000001D;
+            if (Math.abs(vec31.x()) < 1.0000001D && Math.abs(vec31.y()) < 1.0000001D && Math.abs(vec31.z()) < 1.0000001D) {
+                Direction direction = blockhitresult.getDirection();
+                this.player.resetLastActionTime();
+                int i = this.player.level.getMaxBuildHeight();
+                if (blockpos.getY() < i) {
+                    if (this.awaitingPositionFromClient == null && this.player.canInteractWith(blockpos, 3) && serverlevel.mayInteract(this.player, blockpos)) {
+                        //this.player.stopUsingItem(); // CraftBukkit - SPIGOT-4706 //Magma - NO! This breaks item holding with specific mods
+                        InteractionResult interactionresult = this.player.gameMode.useItemOn(this.player, serverlevel, itemstack, interactionhand, blockhitresult);
+                        if (direction == Direction.UP && !interactionresult.consumesAction() && blockpos.getY() >= i - 1 && wasBlockPlacementAttempt(this.player, itemstack)) {
+                            Component component = (new TranslatableComponent("build.tooHigh", i - 1)).withStyle(ChatFormatting.RED);
+                            this.player.sendMessage(component, ChatType.GAME_INFO, Util.NIL_UUID);
+                        } else if (interactionresult.shouldSwing()) {
+                            this.player.swing(interactionhand, true);
+                        }
+                    }
+                } else {
+                    Component component1 = (new TranslatableComponent("build.tooHigh", i - 1)).withStyle(ChatFormatting.RED);
+                    this.player.sendMessage(component1, ChatType.GAME_INFO, Util.NIL_UUID);
+                }
+
+                this.player.connection.send(new ClientboundBlockUpdatePacket(serverlevel, blockpos));
+                this.player.connection.send(new ClientboundBlockUpdatePacket(serverlevel, blockpos.relative(direction)));
+            } else {
+                LOGGER.warn("Ignoring UseItemOnPacket from {}: org.bukkit.Location {} too far away from hit block {}.", this.player.getGameProfile().getName(), vec3, blockpos);
+            }
+        } else {
+            LOGGER.warn("Ignoring UseItemOnPacket from {}: hit position {} too far away from player {}.", this.player.getGameProfile().getName(), blockpos, this.player.blockPosition());
+        }
+    }
+
+    // Spigot start - limit place/interactions
+    private int limitedPackets;
+    private long lastLimitedPacket = -1;
+
+    private boolean checkLimit(long timestamp) {
+        if (lastLimitedPacket != -1 && timestamp - lastLimitedPacket < 30 && limitedPackets++ >= 4) {
+            return false;
+        }
+
+        if (lastLimitedPacket == -1 || timestamp - lastLimitedPacket >= 30) {
+            lastLimitedPacket = timestamp;
+            limitedPackets = 0;
             return true;
-         }
-      }
-
-      return false;
-   }
-
-   public void dismount(double p_143612_, double p_143613_, double p_143614_, float p_143615_, float p_143616_) {
-      this.teleport(p_143612_, p_143613_, p_143614_, p_143615_, p_143616_, Collections.emptySet(), true);
-   }
-
-   public void teleport(double p_9775_, double p_9776_, double p_9777_, float p_9778_, float p_9779_) {
-      this.teleport(p_9775_, p_9776_, p_9777_, p_9778_, p_9779_, Collections.emptySet(), false);
-   }
-
-   public void teleport(double p_9781_, double p_9782_, double p_9783_, float p_9784_, float p_9785_, Set<ClientboundPlayerPositionPacket.RelativeArgument> p_9786_) {
-      this.teleport(p_9781_, p_9782_, p_9783_, p_9784_, p_9785_, p_9786_, false);
-   }
-
-   public void teleport(double p_143618_, double p_143619_, double p_143620_, float p_143621_, float p_143622_, Set<ClientboundPlayerPositionPacket.RelativeArgument> p_143623_, boolean p_143624_) {
-      double d0 = p_143623_.contains(ClientboundPlayerPositionPacket.RelativeArgument.X) ? this.player.getX() : 0.0D;
-      double d1 = p_143623_.contains(ClientboundPlayerPositionPacket.RelativeArgument.Y) ? this.player.getY() : 0.0D;
-      double d2 = p_143623_.contains(ClientboundPlayerPositionPacket.RelativeArgument.Z) ? this.player.getZ() : 0.0D;
-      float f = p_143623_.contains(ClientboundPlayerPositionPacket.RelativeArgument.Y_ROT) ? this.player.getYRot() : 0.0F;
-      float f1 = p_143623_.contains(ClientboundPlayerPositionPacket.RelativeArgument.X_ROT) ? this.player.getXRot() : 0.0F;
-      this.awaitingPositionFromClient = new Vec3(p_143618_, p_143619_, p_143620_);
-      if (++this.awaitingTeleport == Integer.MAX_VALUE) {
-         this.awaitingTeleport = 0;
-      }
-
-      this.awaitingTeleportTime = this.tickCount;
-      this.player.absMoveTo(p_143618_, p_143619_, p_143620_, p_143621_, p_143622_);
-      this.player.connection.send(new ClientboundPlayerPositionPacket(p_143618_ - d0, p_143619_ - d1, p_143620_ - d2, p_143621_ - f, p_143622_ - f1, p_143623_, this.awaitingTeleport, p_143624_));
-   }
-
-   public void handlePlayerAction(ServerboundPlayerActionPacket p_9889_) {
-      PacketUtils.ensureRunningOnSameThread(p_9889_, this, this.player.getLevel());
-      BlockPos blockpos = p_9889_.getPos();
-      this.player.resetLastActionTime();
-      ServerboundPlayerActionPacket.Action serverboundplayeractionpacket$action = p_9889_.getAction();
-      switch(serverboundplayeractionpacket$action) {
-      case SWAP_ITEM_WITH_OFFHAND:
-         if (!this.player.isSpectator()) {
-            ItemStack itemstack = this.player.getItemInHand(InteractionHand.OFF_HAND);
-            this.player.setItemInHand(InteractionHand.OFF_HAND, this.player.getItemInHand(InteractionHand.MAIN_HAND));
-            this.player.setItemInHand(InteractionHand.MAIN_HAND, itemstack);
-            this.player.stopUsingItem();
-         }
-
-         return;
-      case DROP_ITEM:
-         if (!this.player.isSpectator()) {
-            this.player.drop(false);
-         }
-
-         return;
-      case DROP_ALL_ITEMS:
-         if (!this.player.isSpectator()) {
-            this.player.drop(true);
-         }
-
-         return;
-      case RELEASE_USE_ITEM:
-         this.player.releaseUsingItem();
-         return;
-      case START_DESTROY_BLOCK:
-      case ABORT_DESTROY_BLOCK:
-      case STOP_DESTROY_BLOCK:
-         this.player.gameMode.handleBlockBreakAction(blockpos, serverboundplayeractionpacket$action, p_9889_.getDirection(), this.player.level.getMaxBuildHeight());
-         return;
-      default:
-         throw new IllegalArgumentException("Invalid player action");
-      }
-   }
-
-   private static boolean wasBlockPlacementAttempt(ServerPlayer p_9791_, ItemStack p_9792_) {
-      if (p_9792_.isEmpty()) {
-         return false;
-      } else {
-         Item item = p_9792_.getItem();
-         return (item instanceof BlockItem || item instanceof BucketItem) && !p_9791_.getCooldowns().isOnCooldown(item);
-      }
-   }
-
-   public void handleUseItemOn(ServerboundUseItemOnPacket p_9930_) {
-      PacketUtils.ensureRunningOnSameThread(p_9930_, this, this.player.getLevel());
-      ServerLevel serverlevel = this.player.getLevel();
-      InteractionHand interactionhand = p_9930_.getHand();
-      ItemStack itemstack = this.player.getItemInHand(interactionhand);
-      BlockHitResult blockhitresult = p_9930_.getHitResult();
-      Vec3 vec3 = blockhitresult.getLocation();
-      BlockPos blockpos = blockhitresult.getBlockPos();
-      Vec3 vec31 = vec3.subtract(Vec3.atCenterOf(blockpos));
-      if (this.player.level.getServer() != null && this.player.chunkPosition().getChessboardDistance(new ChunkPos(blockpos)) < this.player.level.getServer().getPlayerList().getViewDistance()) {
-         double d0 = 1.0000001D;
-         if (Math.abs(vec31.x()) < 1.0000001D && Math.abs(vec31.y()) < 1.0000001D && Math.abs(vec31.z()) < 1.0000001D) {
-            Direction direction = blockhitresult.getDirection();
-            this.player.resetLastActionTime();
-            int i = this.player.level.getMaxBuildHeight();
-            if (blockpos.getY() < i) {
-               if (this.awaitingPositionFromClient == null && this.player.distanceToSqr((double)blockpos.getX() + 0.5D, (double)blockpos.getY() + 0.5D, (double)blockpos.getZ() + 0.5D) < 64.0D && serverlevel.mayInteract(this.player, blockpos)) {
-                  InteractionResult interactionresult = this.player.gameMode.useItemOn(this.player, serverlevel, itemstack, interactionhand, blockhitresult);
-                  if (direction == Direction.UP && !interactionresult.consumesAction() && blockpos.getY() >= i - 1 && wasBlockPlacementAttempt(this.player, itemstack)) {
-                     Component component = (new TranslatableComponent("build.tooHigh", i - 1)).withStyle(ChatFormatting.RED);
-                     this.player.sendMessage(component, ChatType.GAME_INFO, Util.NIL_UUID);
-                  } else if (interactionresult.shouldSwing()) {
-                     this.player.swing(interactionhand, true);
-                  }
-               }
-            } else {
-               Component component1 = (new TranslatableComponent("build.tooHigh", i - 1)).withStyle(ChatFormatting.RED);
-               this.player.sendMessage(component1, ChatType.GAME_INFO, Util.NIL_UUID);
-            }
-
-            this.player.connection.send(new ClientboundBlockUpdatePacket(serverlevel, blockpos));
-            this.player.connection.send(new ClientboundBlockUpdatePacket(serverlevel, blockpos.relative(direction)));
-         } else {
-            LOGGER.warn("Ignoring UseItemOnPacket from {}: Location {} too far away from hit block {}.", this.player.getGameProfile().getName(), vec3, blockpos);
-         }
-      } else {
-         LOGGER.warn("Ignoring UseItemOnPacket from {}: hit position {} too far away from player {}.", this.player.getGameProfile().getName(), blockpos, this.player.blockPosition());
-      }
-   }
-
-   public void handleUseItem(ServerboundUseItemPacket p_9932_) {
-      PacketUtils.ensureRunningOnSameThread(p_9932_, this, this.player.getLevel());
-      ServerLevel serverlevel = this.player.getLevel();
-      InteractionHand interactionhand = p_9932_.getHand();
-      ItemStack itemstack = this.player.getItemInHand(interactionhand);
-      this.player.resetLastActionTime();
-      if (!itemstack.isEmpty()) {
-         InteractionResult interactionresult = this.player.gameMode.useItem(this.player, serverlevel, itemstack, interactionhand);
-         if (interactionresult.shouldSwing()) {
-            this.player.swing(interactionhand, true);
-         }
-
-      }
-   }
-
-   public void handleTeleportToEntityPacket(ServerboundTeleportToEntityPacket p_9928_) {
-      PacketUtils.ensureRunningOnSameThread(p_9928_, this, this.player.getLevel());
-      if (this.player.isSpectator()) {
-         for(ServerLevel serverlevel : this.server.getAllLevels()) {
-            Entity entity = p_9928_.getEntity(serverlevel);
-            if (entity != null) {
-               this.player.teleportTo(serverlevel, entity.getX(), entity.getY(), entity.getZ(), entity.getYRot(), entity.getXRot());
-               return;
-            }
-         }
-      }
-
-   }
-
-   public void handleResourcePackResponse(ServerboundResourcePackPacket p_9901_) {
-      PacketUtils.ensureRunningOnSameThread(p_9901_, this, this.player.getLevel());
-      if (p_9901_.getAction() == ServerboundResourcePackPacket.Action.DECLINED && this.server.isResourcePackRequired()) {
-         LOGGER.info("Disconnecting {} due to resource pack rejection", (Object)this.player.getName());
-         this.disconnect(new TranslatableComponent("multiplayer.requiredTexturePrompt.disconnect"));
-      }
-
-   }
-
-   public void handlePaddleBoat(ServerboundPaddleBoatPacket p_9878_) {
-      PacketUtils.ensureRunningOnSameThread(p_9878_, this, this.player.getLevel());
-      Entity entity = this.player.getVehicle();
-      if (entity instanceof Boat) {
-         ((Boat)entity).setPaddleState(p_9878_.getLeft(), p_9878_.getRight());
-      }
-
-   }
-
-   public void handlePong(ServerboundPongPacket p_143652_) {
-   }
-
-   public void onDisconnect(Component p_9825_) {
-      LOGGER.info("{} lost connection: {}", this.player.getName().getString(), p_9825_.getString());
-      this.server.invalidateStatus();
-      this.server.getPlayerList().broadcastMessage((new TranslatableComponent("multiplayer.player.left", this.player.getDisplayName())).withStyle(ChatFormatting.YELLOW), ChatType.SYSTEM, Util.NIL_UUID);
-      this.player.disconnect();
-      this.server.getPlayerList().remove(this.player);
-      this.player.getTextFilter().leave();
-      if (this.isSingleplayerOwner()) {
-         LOGGER.info("Stopping singleplayer server as player logged out");
-         this.server.halt(false);
-      }
-
-   }
-
-   public void send(Packet<?> p_9830_) {
-      this.send(p_9830_, (GenericFutureListener<? extends Future<? super Void>>)null);
-   }
-
-   public void send(Packet<?> p_9832_, @Nullable GenericFutureListener<? extends Future<? super Void>> p_9833_) {
-      try {
-         this.connection.send(p_9832_, p_9833_);
-      } catch (Throwable throwable) {
-         CrashReport crashreport = CrashReport.forThrowable(throwable, "Sending packet");
-         CrashReportCategory crashreportcategory = crashreport.addCategory("Packet being sent");
-         crashreportcategory.setDetail("Packet class", () -> {
-            return p_9832_.getClass().getCanonicalName();
-         });
-         throw new ReportedException(crashreport);
-      }
-   }
-
-   public void handleSetCarriedItem(ServerboundSetCarriedItemPacket p_9909_) {
-      PacketUtils.ensureRunningOnSameThread(p_9909_, this, this.player.getLevel());
-      if (p_9909_.getSlot() >= 0 && p_9909_.getSlot() < Inventory.getSelectionSize()) {
-         if (this.player.getInventory().selected != p_9909_.getSlot() && this.player.getUsedItemHand() == InteractionHand.MAIN_HAND) {
-            this.player.stopUsingItem();
-         }
-
-         this.player.getInventory().selected = p_9909_.getSlot();
-         this.player.resetLastActionTime();
-      } else {
-         LOGGER.warn("{} tried to set an invalid carried item", (Object)this.player.getName().getString());
-      }
-   }
-
-   public void handleChat(ServerboundChatPacket p_9841_) {
-      String s = StringUtils.normalizeSpace(p_9841_.getMessage());
-
-      for(int i = 0; i < s.length(); ++i) {
-         if (!SharedConstants.isAllowedChatCharacter(s.charAt(i))) {
-            this.disconnect(new TranslatableComponent("multiplayer.disconnect.illegal_characters"));
-            return;
-         }
-      }
-
-      if (s.startsWith("/")) {
-         PacketUtils.ensureRunningOnSameThread(p_9841_, this, this.player.getLevel());
-         this.handleChat(TextFilter.FilteredText.passThrough(s));
-      } else {
-         this.filterTextPacket(s, this::handleChat);
-      }
-
-   }
-
-   private void handleChat(TextFilter.FilteredText p_143629_) {
-      if (this.player.getChatVisibility() == ChatVisiblity.HIDDEN) {
-         this.send(new ClientboundChatPacket((new TranslatableComponent("chat.disabled.options")).withStyle(ChatFormatting.RED), ChatType.SYSTEM, Util.NIL_UUID));
-      } else {
-         this.player.resetLastActionTime();
-         String s = p_143629_.getRaw();
-         if (s.startsWith("/")) {
+        }
+
+        return true;
+    }
+    // Spigot end
+
+
+    public void handleUseItem(ServerboundUseItemPacket p_9932_) {
+        PacketUtils.ensureRunningOnSameThread( p_9932_, this, this.player.getLevel() );
+        if (this.player.isImmobile()) return; // CraftBukkit
+        if (!checkLimit(p_9932_.timestamp)) return; // Spigot - check limit
+        ServerLevel serverlevel = this.player.getLevel();
+        InteractionHand interactionhand = p_9932_.getHand();
+        ItemStack itemstack = this.player.getItemInHand( interactionhand );
+        this.player.resetLastActionTime();
+        if (!itemstack.isEmpty()) {
+            // CraftBukkit start
+            // Raytrace to look for 'rogue armswings'
+            float f1 = this.player.getXRot();
+            float f2 = this.player.getYRot();
+            double d0 = this.player.getX();
+            double d1 = this.player.getY() + (double) this.player.getEyeHeight();
+            double d2 = this.player.getZ();
+            Vec3 vec3d = new Vec3(d0, d1, d2);
+            float f3 = Mth.cos(-f2 * 0.017453292F - 3.1415927F);
+            float f4 = Mth.sin(-f2 * 0.017453292F - 3.1415927F);
+            float f5 = -Mth.cos(-f1 * 0.017453292F);
+            float f6 = Mth.sin(-f1 * 0.017453292F);
+            float f7 = f4 * f5;
+            float f8 = f3 * f5;
+            double d3 = player.gameMode.getGameModeForPlayer()== GameType.CREATIVE ? 5.0D : 4.5D;
+            Vec3 vec3d1 = vec3d.add((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
+            net.minecraft.world.phys.HitResult movingobjectposition = this.player.level.clip(new net.minecraft.world.level.ClipContext(vec3d, vec3d1, net.minecraft.world.level.ClipContext.Block.OUTLINE, net.minecraft.world.level.ClipContext.Fluid.NONE, player));
+
+            boolean cancelled;
+            if (movingobjectposition == null || movingobjectposition.getType() != net.minecraft.world.phys.HitResult.Type.BLOCK) {
+                org.bukkit.event.player.PlayerInteractEvent event = org.bukkit.craftbukkit.v1_18_R2.event.CraftEventFactory.callPlayerInteractEvent(this.player, org.bukkit.event.block.Action.RIGHT_CLICK_AIR, itemstack, interactionhand);
+                cancelled = event.useItemInHand() == org.bukkit.event.Event.Result.DENY;
+            } else {
+                BlockHitResult movingobjectpositionblock = (BlockHitResult) movingobjectposition;
+                if (player.gameMode.firedInteract && player.gameMode.interactPosition.equals(movingobjectpositionblock.getBlockPos()) && player.gameMode.interactHand == interactionhand && ItemStack.tagMatches(player.gameMode.interactItemStack, itemstack)) {
+                    cancelled = player.gameMode.interactResult;
+                } else {
+                    org.bukkit.event.player.PlayerInteractEvent event = org.bukkit.craftbukkit.v1_18_R2.event.CraftEventFactory.callPlayerInteractEvent(player, org.bukkit.event.block.Action.RIGHT_CLICK_BLOCK, movingobjectpositionblock.getBlockPos(), movingobjectpositionblock.getDirection(), itemstack, true, interactionhand);
+                    cancelled = event.useItemInHand() == org.bukkit.event.Event.Result.DENY;
+                }
+                player.gameMode.firedInteract = false;
+            }
+            if (cancelled) {
+                this.player.getBukkitEntity().updateInventory(); // SPIGOT-2524
+                return;
+            }
+            InteractionResult interactionresult = this.player.gameMode.useItem( this.player, serverlevel, itemstack, interactionhand );
+            if (interactionresult.shouldSwing()) {
+                this.player.swing( interactionhand, true );
+            }
+
+        }
+    }
+
+    public void handleTeleportToEntityPacket(ServerboundTeleportToEntityPacket p_9928_) {
+        PacketUtils.ensureRunningOnSameThread( p_9928_, this, this.player.getLevel() );
+        if (this.player.isSpectator()) {
+            for (ServerLevel serverlevel : this.server.getAllLevels()) {
+                Entity entity = p_9928_.getEntity( serverlevel );
+                if (entity != null) {
+                    this.player.teleportTo( serverlevel, entity.getX(), entity.getY(), entity.getZ(), entity.getYRot(), entity.getXRot() , org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.SPECTATE); // CraftBukkit
+                    return;
+                }
+            }
+        }
+
+    }
+
+    public void handleResourcePackResponse(ServerboundResourcePackPacket p_9901_) {
+        PacketUtils.ensureRunningOnSameThread( p_9901_, this, this.player.getLevel() );
+        if (p_9901_.getAction() == ServerboundResourcePackPacket.Action.DECLINED && this.server.isResourcePackRequired()) {
+            LOGGER.info( "Disconnecting {} due to resource pack rejection", (Object) this.player.getName() );
+            this.disconnect( new TranslatableComponent( "multiplayer.requiredTexturePrompt.disconnect" ) );
+        }
+//        this.cserver.getPluginManager().callEvent(new org.bukkit.event.player.PlayerResourcePackStatusEvent(getCraftPlayer(), org.bukkit.event.player.PlayerResourcePackStatusEvent.Status.values()[p_9901_.action.ordinal()])); // CraftBukkit
+    }
+
+    public void handlePaddleBoat(ServerboundPaddleBoatPacket p_9878_) {
+        PacketUtils.ensureRunningOnSameThread( p_9878_, this, this.player.getLevel() );
+        Entity entity = this.player.getVehicle();
+        if (entity instanceof Boat) {
+            ((Boat) entity).setPaddleState( p_9878_.getLeft(), p_9878_.getRight() );
+        }
+
+    }
+
+    public void handlePong(ServerboundPongPacket p_143652_) {
+    }
+
+    public void onDisconnect(Component p_9825_) {
+        // CraftBukkit start - Rarely it would send a disconnect line twice
+        if (this.processedDisconnect) {
+            return;
+        } else {
+            this.processedDisconnect = true;
+        }
+        // CraftBukkit end
+        LOGGER.info( "{} lost connection: {}", this.player.getName().getString(), p_9825_.getString() );
+        // CraftBukkit start - Replace vanilla quit message handling with our own.
+        /*
+        this.server.invalidateStatus();
+        this.server.getPlayerList().broadcastMessage( (new TranslatableComponent( "multiplayer.player.left", this.player.getDisplayName() )).withStyle( ChatFormatting.YELLOW ), ChatType.SYSTEM, Util.NIL_UUID );
+        */
+        this.player.disconnect();
+        String defaultQuitMessage = ChatFormatting.YELLOW + this.player.getName().getString() + " left the game";
+        String quitMessage = this.server.getPlayerList().removeAndReturn(this.player);
+        if (((quitMessage != null) && (quitMessage.length() > 0))) { //Check if bukkit hasn't cancelled the quit message
+            if (!java.util.Objects.equals(quitMessage, defaultQuitMessage)) //If the message is not the default one, broadcast it, otherwise we let mixins handle it
+                this.server.getPlayerList().broadcastMessage(org.bukkit.craftbukkit.v1_18_R2.util.CraftChatMessage.fromString(quitMessage));
+            else
+                this.server.getPlayerList().broadcastMessage((new TranslatableComponent("multiplayer.player.left", this.player.getDisplayName())).withStyle(ChatFormatting.YELLOW), ChatType.SYSTEM, Util.NIL_UUID);
+        }
+        // CraftBukkit end
+        this.player.getTextFilter().leave();
+        if (this.isSingleplayerOwner()) {
+            LOGGER.info( "Stopping singleplayer server as player logged out" );
+            this.server.halt( false );
+        }
+
+    }
+
+    public void send(Packet<?> p_9830_) {
+        this.send( p_9830_, (GenericFutureListener<? extends Future<? super Void>>) null );
+    }
+
+    public void send(Packet<?> p_9832_, @Nullable GenericFutureListener<? extends Future<? super Void>> p_9833_) {
+        // CraftBukkit start
+        if (p_9832_ == null || this.processedDisconnect) { // Spigot
+            return;
+        } else if (p_9832_ instanceof net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket) {
+            net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket packet6 = (net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket) p_9832_;
+            this.player.compassTarget = new org.bukkit.Location(this.getCraftPlayer().getWorld(), packet6.pos.getX(), packet6.pos.getY(), packet6.pos.getZ());
+        }
+        // CraftBukkit end
+        //Magma start - capture dimension packets
+        org.magmafoundation.magma.helpers.BorderHelper.captureBorderPacket(p_9832_, this.player);
+        try {
+            this.connection.send( p_9832_, p_9833_ );
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.forThrowable( throwable, "Sending packet" );
+            CrashReportCategory crashreportcategory = crashreport.addCategory( "Packet being sent" );
+            crashreportcategory.setDetail( "Packet class", () -> {
+                return p_9832_.getClass().getCanonicalName();
+            } );
+            throw new ReportedException( crashreport );
+        } finally {
+            org.magmafoundation.magma.helpers.BorderHelper.clearCapture(p_9832_);
+            //Magma end
+        }
+    }
+
+    public void handleSetCarriedItem(ServerboundSetCarriedItemPacket p_9909_) {
+        PacketUtils.ensureRunningOnSameThread( p_9909_, this, this.player.getLevel() );
+        if (this.player.isImmobile()) return; // CraftBukkit
+        if (p_9909_.getSlot() >= 0 && p_9909_.getSlot() < Inventory.getSelectionSize()) {
+            org.bukkit.event.player.PlayerItemHeldEvent event = new org.bukkit.event.player.PlayerItemHeldEvent(this.getCraftPlayer(), this.player.getInventory().selected, p_9909_.getSlot());
+            this.cserver.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                this.send(new ClientboundSetCarriedItemPacket(this.player.getInventory().selected));
+                this.player.resetLastActionTime();
+                return;
+            }
+            // CraftBukkit end
+            if (this.player.getInventory().selected != p_9909_.getSlot() && this.player.getUsedItemHand() == InteractionHand.MAIN_HAND) {
+                this.player.stopUsingItem();
+            }
+
+            this.player.getInventory().selected = p_9909_.getSlot();
+            this.player.resetLastActionTime();
+        } else {
+            LOGGER.warn( "{} tried to set an invalid carried item", (Object) this.player.getName().getString() );
+            this.disconnect("Invalid hotbar selection (Hacking?)"); // CraftBukkit
+        }
+    }
+
+    public void handleChat(ServerboundChatPacket p_9841_) {
+        // CraftBukkit start - async chat
+        // SPIGOT-3638
+        if (this.server.isStopped()) {
+            return;
+        }
+        // CraftBukkit end
+        String s = org.apache.commons.lang3.StringUtils.normalizeSpace( p_9841_.getMessage() );
+
+        for (int i = 0; i < s.length(); ++i) {
+            if (!SharedConstants.isAllowedChatCharacter( s.charAt( i ) )) {
+                this.disconnect( new TranslatableComponent( "multiplayer.disconnect.illegal_characters" ) );
+                return;
+            }
+        }
+
+        if (s.startsWith( "/" )) {
+            PacketUtils.ensureRunningOnSameThread( p_9841_, this, this.player.getLevel() );
+            this.handleChat( TextFilter.FilteredText.passThrough( s ) );
+        } else {
+            this.handleChat(TextFilter.FilteredText.passThrough(s)); // CraftBukkit - filter NYI
+        }
+
+    }
+
+    // CraftBukkit start - add method //Magma - implement ArcLight version
+    private void handleChat(TextFilter.FilteredText p_143629_) {
+        if (this.player.isRemoved() || this.player.getChatVisibility() == ChatVisiblity.HIDDEN) {
+            this.send(new ClientboundChatPacket((new TranslatableComponent("chat.cannotSend")).withStyle(ChatFormatting.RED), ChatType.SYSTEM, Util.NIL_UUID));
+        } else {
+            this.player.resetLastActionTime();
+            String s = p_143629_.getRaw();
+            boolean isSync = s.startsWith("/");
+            if (isSync) {
+                try {
+                    this.cserver.playerCommandState = true;
+                    this.handleCommand(s);
+                } finally {
+                    this.cserver.playerCommandState = false;
+                }
+            } else if (s.isEmpty()) {
+                LOGGER.warn(this.player.getScoreboardName() + " tried to send an empty message");
+            } else if (this.getCraftPlayer().isConversing()) {
+                String conversationInput = s;
+                this.server.processQueue.add(() -> this.getCraftPlayer().acceptConversationInput(conversationInput));
+            } else if (this.player.getChatVisibility() == ChatVisiblity.SYSTEM) {
+                this.send(new ClientboundChatPacket((new TranslatableComponent("chat.cannotSend")).withStyle(ChatFormatting.RED), ChatType.SYSTEM, Util.NIL_UUID));
+            } else {
+                this.chat(s, true);
+            }
+
+            boolean counted = true;
+            for (String exclude : org.spigotmc.SpigotConfig.spamExclusions) {
+                if (exclude != null && s.startsWith(exclude)) {
+                    counted = false;
+                    break;
+                }
+            }
+            if (counted) {
+                this.chatSpamTickCount += 20;
+                if (this.chatSpamTickCount > 200 && !this.server.getPlayerList().isOp(this.player.getGameProfile())) {
+                    if (!isSync) {
+                        class Disconnect2 extends org.bukkit.craftbukkit.v1_18_R2.util.Waitable<Object> {
+
+                            @Override
+                            protected Object evaluate() {
+                                disconnect(new TranslatableComponent("disconnect.spam"));
+                                return null;
+                            }
+                        }
+                        org.bukkit.craftbukkit.v1_18_R2.util.Waitable<Object> waitable2 = new Disconnect2();
+                        this.server.processQueue.add(waitable2);
+                        try {
+                            waitable2.get();
+                            return;
+                        } catch (InterruptedException e4) {
+                            Thread.currentThread().interrupt();
+                            return;
+                        } catch (java.util.concurrent.ExecutionException e2) {
+                            throw new RuntimeException(e2);
+                        }
+                    }
+                    this.disconnect(new TranslatableComponent("disconnect.spam"));
+                }
+            }
+        }
+    }
+
+    private void handleCommand(String p_9958_) {
+        co.aikar.timings.MinecraftTimings.playerCommandTimer.startTiming(); // Paper
+        // CraftBukkit start - whole method
+        if ( org.spigotmc.SpigotConfig.logCommands ) // Spigot
+            LOGGER.info( this.player.getScoreboardName() + " issued server command: " + p_9958_ );
+
+        org.bukkit.craftbukkit.v1_18_R2.entity.CraftPlayer player = this.getCraftPlayer();
+
+        org.bukkit.event.player.PlayerCommandPreprocessEvent event = new org.bukkit.event.player.PlayerCommandPreprocessEvent( player, p_9958_, new org.bukkit.craftbukkit.v1_18_R2.util.LazyPlayerSet( server ) );
+        this.cserver.getPluginManager().callEvent( event );
+
+        if (event.isCancelled()) {
+            co.aikar.timings.MinecraftTimings.playerCommandTimer.stopTiming(); // Paper
+            return;
+        }
+
+        try {
+            if (this.cserver.dispatchCommand( event.getPlayer(), event.getMessage().substring( 1 ) )) {
+                return;
+            }
+        } catch (org.bukkit.command.CommandException ex) {
+            player.sendMessage( org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command" );
+            java.util.logging.Logger.getLogger( ServerGamePacketListenerImpl.class.getName() ).log( java.util.logging.Level.SEVERE, null, ex );
+            return;
+        } finally {
+            co.aikar.timings.MinecraftTimings.playerCommandTimer.stopTiming(); // Paper
+        }
+        // this.server.getCommands().performCommand(this.player.createCommandSourceStack(), p_9958_);
+        // CraftBukkit end
+    }
+
+    public void handleAnimate(ServerboundSwingPacket p_9926_) {
+        PacketUtils.ensureRunningOnSameThread( p_9926_, this, this.player.getLevel() );
+        if (this.player.isImmobile()) return; // CraftBukkit
+        this.player.resetLastActionTime();
+        // CraftBukkit start - Raytrace to look for 'rogue armswings'
+        float f1 = this.player.getXRot();
+        float f2 = this.player.getYRot();
+        double d0 = this.player.getX();
+        double d1 = this.player.getY() + (double) this.player.getEyeHeight();
+        double d2 = this.player.getZ();
+        Vec3 vec3d = new Vec3(d0, d1, d2);
+
+        float f3 = Mth.cos(-f2 * 0.017453292F - 3.1415927F);
+        float f4 = Mth.sin(-f2 * 0.017453292F - 3.1415927F);
+        float f5 = -Mth.cos(-f1 * 0.017453292F);
+        float f6 = Mth.sin(-f1 * 0.017453292F);
+        float f7 = f4 * f5;
+        float f8 = f3 * f5;
+        double d3 = player.gameMode.getGameModeForPlayer()== GameType.CREATIVE ? 5.0D : 4.5D;
+        Vec3 vec3d1 = vec3d.add((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
+        net.minecraft.world.phys.HitResult movingobjectposition = this.player.level.clip(new net.minecraft.world.level.ClipContext(vec3d, vec3d1, net.minecraft.world.level.ClipContext.Block.OUTLINE, net.minecraft.world.level.ClipContext.Fluid.NONE, player));
+
+        if (movingobjectposition == null || movingobjectposition.getType() != net.minecraft.world.phys.HitResult.Type.BLOCK) {
+            org.bukkit.craftbukkit.v1_18_R2.event.CraftEventFactory.callPlayerInteractEvent(this.player, org.bukkit.event.block.Action.LEFT_CLICK_AIR, this.player.getInventory().getSelected(), InteractionHand.MAIN_HAND);
+        }
+
+        // Arm swing animation
+        org.bukkit.event.player.PlayerAnimationEvent event = new org.bukkit.event.player.PlayerAnimationEvent(this.getCraftPlayer());
+        this.cserver.getPluginManager().callEvent(event);
+
+        if (event.isCancelled()) return;
+        // CraftBukkit end
+        this.player.swing( p_9926_.getHand() );
+    }
+
+    public void handlePlayerCommand(ServerboundPlayerCommandPacket p_9891_) {
+        PacketUtils.ensureRunningOnSameThread( p_9891_, this, this.player.getLevel() );
+        // CraftBukkit start
+        if (this.player.isRemoved()) return;
+        switch (p_9891_.getAction()) {
+            case PRESS_SHIFT_KEY:
+            case RELEASE_SHIFT_KEY:
+                org.bukkit.event.player.PlayerToggleSneakEvent event = new org.bukkit.event.player.PlayerToggleSneakEvent(this.getCraftPlayer(), p_9891_.getAction() == ServerboundPlayerCommandPacket.Action.PRESS_SHIFT_KEY);
+                this.cserver.getPluginManager().callEvent(event);
+                if (event.isCancelled()) {
+                    return;
+                }
+                break;
+            case START_SPRINTING:
+            case STOP_SPRINTING:
+                org.bukkit.event.player.PlayerToggleSprintEvent e2 = new org.bukkit.event.player.PlayerToggleSprintEvent(this.getCraftPlayer(), p_9891_.getAction() == ServerboundPlayerCommandPacket.Action.START_SPRINTING);
+                this.cserver.getPluginManager().callEvent(e2);
+                if (e2.isCancelled()) {
+                    return;
+                }
+                break;
+        }
+        // CraftBukkit end
+        this.player.resetLastActionTime();
+        switch (p_9891_.getAction()) {
+            case PRESS_SHIFT_KEY:
+                this.player.setShiftKeyDown( true );
+                break;
+            case RELEASE_SHIFT_KEY:
+                this.player.setShiftKeyDown( false );
+                break;
+            case START_SPRINTING:
+                this.player.setSprinting( true );
+                break;
+            case STOP_SPRINTING:
+                this.player.setSprinting( false );
+                break;
+            case STOP_SLEEPING:
+                if (this.player.isSleeping()) {
+                    this.player.stopSleepInBed( false, true );
+                    this.awaitingPositionFromClient = this.player.position();
+                }
+                break;
+            case START_RIDING_JUMP:
+                if (this.player.getVehicle() instanceof PlayerRideableJumping) {
+                    PlayerRideableJumping playerrideablejumping1 = (PlayerRideableJumping) this.player.getVehicle();
+                    int i = p_9891_.getData();
+                    if (playerrideablejumping1.canJump() && i > 0) {
+                        playerrideablejumping1.handleStartJump( i );
+                    }
+                }
+                break;
+            case STOP_RIDING_JUMP:
+                if (this.player.getVehicle() instanceof PlayerRideableJumping) {
+                    PlayerRideableJumping playerrideablejumping = (PlayerRideableJumping) this.player.getVehicle();
+                    playerrideablejumping.handleStopJump();
+                }
+                break;
+            case OPEN_INVENTORY:
+                if (this.player.getVehicle() instanceof AbstractHorse) {
+                    ((AbstractHorse) this.player.getVehicle()).openInventory( this.player );
+                }
+                break;
+            case START_FALL_FLYING:
+                if (!this.player.tryToStartFallFlying()) {
+                    this.player.stopFallFlying();
+                }
+                break;
+            default:
+                throw new IllegalArgumentException( "Invalid client command!" );
+        }
+
+    }
+
+    public void handleInteract(ServerboundInteractPacket p_9866_) {
+        PacketUtils.ensureRunningOnSameThread( p_9866_, this, this.player.getLevel() );
+        if (this.player.isImmobile()) return; // CraftBukkit
+        ServerLevel serverlevel = this.player.getLevel();
+        final Entity entity = p_9866_.getTarget( serverlevel );
+        // Spigot Start
+        if ( entity == player && !player.isSpectator() )
+        {
+            disconnect( "Cannot interact with self!" );
+            return;
+        }
+        // Spigot End
+        this.player.resetLastActionTime();
+        this.player.setShiftKeyDown( p_9866_.isUsingSecondaryAction() );
+        if (entity != null) {
+            if (!serverlevel.getWorldBorder().isWithinBounds( entity.blockPosition() )) {
+                return;
+            }
+
+            double d0 = 36.0D;
+            if (this.player.distanceToSqr( entity ) < 36.0D) {
+                p_9866_.dispatch( new ServerboundInteractPacket.Handler() {
+                    private void performInteraction(InteractionHand p_143679_, ServerGamePacketListenerImpl.EntityInteraction p_143680_, org.bukkit.event.player.PlayerInteractEntityEvent event) { // CraftBukkit
+                        if(!ServerGamePacketListenerImpl.this.player.canInteractWith(entity, 1.5D)) return; //Forge: If the entity cannot be reached, do nothing. Original check was dist < 6, range is 4.5, so vanilla used padding=1.5
+
+                        ItemStack itemstack = ServerGamePacketListenerImpl.this.player.getItemInHand( p_143679_ ).copy();
+                        // CraftBukkit start
+                        ItemStack itemInHand = ServerGamePacketListenerImpl.this.player.getItemInHand(p_143679_);
+                        boolean triggerLeashUpdate = itemInHand != null && itemInHand.getItem() == Items.LEAD && entity instanceof net.minecraft.world.entity.Mob;
+                        Item origItem = player.getInventory().getSelected() == null ? null : player.getInventory().getSelected().getItem();
+
+                        cserver.getPluginManager().callEvent(event);
+
+                        // Entity in bucket - SPIGOT-4048 and SPIGOT-6859
+                        if ((entity instanceof net.minecraft.world.entity.animal.Bucketable && entity instanceof net.minecraft.world.entity.LivingEntity && origItem != null && origItem.asItem() == Items.WATER_BUCKET) && (event.isCancelled() || player.getInventory().getSelected() == null || player.getInventory().getSelected().getItem() != origItem)) {
+                            send(new net.minecraft.network.protocol.game.ClientboundAddMobPacket((net.minecraft.world.entity.LivingEntity) entity));
+                            player.containerMenu.sendAllDataToRemote();
+                        }
+
+                        if (triggerLeashUpdate && (event.isCancelled() || player.getInventory().getSelected() == null || player.getInventory().getSelected().getItem() != origItem)) {
+                            // Refresh the current leash state
+                            send(new net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket(entity, ((net.minecraft.world.entity.Mob) entity).getLeashHolder()));
+                        }
+
+                        if (event.isCancelled() || player.getInventory().getSelected() == null || player.getInventory().getSelected().getItem() != origItem) {
+                            // Refresh the current entity metadata
+                            send(new net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket(entity.getId(), entity.getEntityData(), true));
+                        }
+
+                        if (event.isCancelled()) {
+                            return;
+                        }
+                        // CraftBukkit end
+                        InteractionResult interactionresult = p_143680_.run( ServerGamePacketListenerImpl.this.player, entity, p_143679_ );
+
+                        // CraftBukkit start
+                        if (!itemInHand.isEmpty() && itemInHand.getCount() <= -1) {
+                            player.containerMenu.sendAllDataToRemote();
+                        }
+                        // CraftBukkit end
+                        if (interactionresult.consumesAction()) {
+                            CriteriaTriggers.PLAYER_INTERACTED_WITH_ENTITY.trigger( ServerGamePacketListenerImpl.this.player, itemstack, entity );
+                            if (interactionresult.shouldSwing()) {
+                                ServerGamePacketListenerImpl.this.player.swing( p_143679_, true );
+                            }
+                        }
+
+                    }
+
+                    public void onInteraction(InteractionHand p_143677_) {
+                        this.performInteraction( p_143677_, Player::interactOn , new org.bukkit.event.player.PlayerInteractEntityEvent(getCraftPlayer(), entity.getBukkitEntity(), (p_143677_ == InteractionHand.OFF_HAND) ? org.bukkit.inventory.EquipmentSlot.OFF_HAND : org.bukkit.inventory.EquipmentSlot.HAND));
+                    }
+
+                    public void onInteraction(InteractionHand p_143682_, Vec3 p_143683_) {
+                        this.performInteraction(p_143682_, (p_143686_, p_143687_, p_143688_) -> {
+                            InteractionResult onInteractEntityAtResult = net.minecraftforge.common.ForgeHooks.onInteractEntityAt(player, entity, p_143683_, p_143682_);
+                            if (onInteractEntityAtResult != null) return onInteractEntityAtResult;
+                            return p_143687_.interactAt(p_143686_, p_143683_, p_143688_);
+                        }, new org.bukkit.event.player.PlayerInteractAtEntityEvent(getCraftPlayer(), entity.getBukkitEntity(), new org.bukkit.util.Vector(p_143683_.x, p_143683_.y, p_143683_.z), (p_143682_ == InteractionHand.OFF_HAND) ? org.bukkit.inventory.EquipmentSlot.OFF_HAND : org.bukkit.inventory.EquipmentSlot.HAND)); // CraftBukkit
+                    }
+
+                    public void onAttack() {
+                        // CraftBukkit start
+                        if (!(entity instanceof ItemEntity) && !(entity instanceof ExperienceOrb) && !(entity instanceof AbstractArrow) && (entity != ServerGamePacketListenerImpl.this.player || player.isSpectator())) {
+                            ItemStack itemInHand = ServerGamePacketListenerImpl.this.player.getMainHandItem();
+                            ServerGamePacketListenerImpl.this.player.attack( entity );
+
+                            if (!itemInHand.isEmpty() && itemInHand.getCount() <= -1) {
+                                player.containerMenu.sendAllDataToRemote();
+                            }
+                            // CraftBukkit end
+                        } else {
+                            ServerGamePacketListenerImpl.this.disconnect( new TranslatableComponent( "multiplayer.disconnect.invalid_entity_attacked" ) );
+                            ServerGamePacketListenerImpl.LOGGER.warn( "Player {} tried to attack an invalid entity", (Object) ServerGamePacketListenerImpl.this.player.getName().getString() );
+                        }
+                    }
+                } );
+            }
+        }
+
+    }
+
+    public void handleClientCommand(ServerboundClientCommandPacket p_9843_) {
+        PacketUtils.ensureRunningOnSameThread( p_9843_, this, this.player.getLevel() );
+        this.player.resetLastActionTime();
+        ServerboundClientCommandPacket.Action serverboundclientcommandpacket$action = p_9843_.getAction();
+        switch (serverboundclientcommandpacket$action) {
+            case PERFORM_RESPAWN:
+                if (this.player.wonGame) {
+                    this.player.wonGame = false;
+                    this.player = this.server.getPlayerList().respawn( this.player, true );
+                    CriteriaTriggers.CHANGED_DIMENSION.trigger( this.player, Level.END, Level.OVERWORLD );
+                } else {
+                    if (this.player.getHealth() > 0.0F) {
+                        return;
+                    }
+
+                    this.player = this.server.getPlayerList().respawn( this.player, false );
+                    if (this.server.isHardcore()) {
+                        this.player.setGameMode( GameType.SPECTATOR );
+                        this.player.getLevel().getGameRules().getRule( GameRules.RULE_SPECTATORSGENERATECHUNKS ).set( false, this.server );
+                    }
+                }
+                break;
+            case REQUEST_STATS:
+                this.player.getStats().sendStats( this.player );
+        }
+
+    }
+
+    public void handleContainerClose(ServerboundContainerClosePacket p_9858_) {
+        PacketUtils.ensureRunningOnSameThread( p_9858_, this, this.player.getLevel() );
+
+        if (this.player.isImmobile()) return; // CraftBukkit
+
+        this.player.doCloseContainer();
+    }
+
+    public void handleContainerClick(ServerboundContainerClickPacket p_9856_) {
+        PacketUtils.ensureRunningOnSameThread( p_9856_, this, this.player.getLevel() );
+        if (this.player.isImmobile()) return; // CraftBukkit
+        this.player.resetLastActionTime();
+        if (this.player.containerMenu.containerId == p_9856_.getContainerId() && this.player.containerMenu.stillValid( this.player )) { // CraftBukkit
+            boolean cancelled = this.player.isSpectator(); // CraftBukkit - see below if
+            if (false/*this.player.isSpectator()*/) { // CraftBukkit
+                this.player.containerMenu.sendAllDataToRemote();
+            } else {
+                int i = p_9856_.getSlotNum();
+                if (!this.player.containerMenu.isValidSlotIndex( i )) {
+                    LOGGER.debug( "Player {} clicked invalid slot index: {}, available slots: {}", this.player.getName(), i, this.player.containerMenu.slots.size() );
+                } else {
+                    boolean flag = p_9856_.getStateId() != this.player.containerMenu.getStateId();
+                    this.player.containerMenu.suppressRemoteUpdates();
+//               this.player.containerMenu.clicked(i, p_9856_.getButtonNum(), p_9856_.getClickType(), this.player);
+
+                    // CraftBukkit start - Call InventoryClickEvent
+                    if (p_9856_.getSlotNum() < -1 && p_9856_.getSlotNum() != -999) {
+                        return;
+                    }
+
+                    // org.magmafoundation.magma.Magma start - capture container owner
+                    org.magmafoundation.magma.helpers.InventoryViewHelper.captureContainerOwner(this.player);
+                    org.bukkit.inventory.InventoryView inventory = this.player.containerMenu.getBukkitView();
+                    org.magmafoundation.magma.helpers.InventoryViewHelper.resetContainerOwner();
+                    // org.magmafoundation.magma.Magma end
+                    org.bukkit.event.inventory.InventoryType.SlotType type = inventory.getSlotType( p_9856_.getSlotNum() );
+
+                    org.bukkit.event.inventory.InventoryClickEvent event;
+                    org.bukkit.event.inventory.ClickType click = org.bukkit.event.inventory.ClickType.UNKNOWN;
+                    org.bukkit.event.inventory.InventoryAction action = org.bukkit.event.inventory.InventoryAction.UNKNOWN;
+
+                    ItemStack itemstack = ItemStack.EMPTY;
+
+                    switch (p_9856_.getClickType()) {
+                        case PICKUP:
+                            if (p_9856_.getButtonNum() == 0) {
+                                click = org.bukkit.event.inventory.ClickType.LEFT;
+                            } else if (p_9856_.getButtonNum() == 1) {
+                                click = org.bukkit.event.inventory.ClickType.RIGHT;
+                            }
+                            if (p_9856_.getButtonNum() == 0 || p_9856_.getButtonNum() == 1) {
+                                action = org.bukkit.event.inventory.InventoryAction.NOTHING; // Don't want to repeat ourselves
+                                if (p_9856_.getSlotNum() == -999) {
+                                    if (!player.containerMenu.getCarried().isEmpty()) {
+                                        action = p_9856_.getButtonNum() == 0 ? org.bukkit.event.inventory.InventoryAction.DROP_ALL_CURSOR : org.bukkit.event.inventory.InventoryAction.DROP_ONE_CURSOR;
+                                    }
+                                } else if (p_9856_.getSlotNum() < 0) {
+                                    action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                } else {
+                                    net.minecraft.world.inventory.Slot slot = this.player.containerMenu.getSlot( p_9856_.getSlotNum() );
+                                    if (slot != null) {
+                                        ItemStack clickedItem = slot.getItem();
+                                        ItemStack cursor = player.containerMenu.getCarried();
+                                        if (clickedItem.isEmpty()) {
+                                            if (!cursor.isEmpty()) {
+                                                action = p_9856_.getButtonNum() == 0 ? org.bukkit.event.inventory.InventoryAction.PLACE_ALL : org.bukkit.event.inventory.InventoryAction.PLACE_ONE;
+                                            }
+                                        } else if (slot.mayPickup( player )) {
+                                            if (cursor.isEmpty()) {
+                                                action = p_9856_.getButtonNum() == 0 ? org.bukkit.event.inventory.InventoryAction.PICKUP_ALL : org.bukkit.event.inventory.InventoryAction.PICKUP_HALF;
+                                            } else if (slot.mayPlace( cursor )) {
+                                                if (clickedItem.sameItem( cursor ) && ItemStack.tagMatches( clickedItem, cursor )) {
+                                                    int toPlace = p_9856_.getButtonNum() == 0 ? cursor.getCount() : 1;
+                                                    toPlace = Math.min( toPlace, clickedItem.getMaxStackSize() - clickedItem.getCount() );
+                                                    toPlace = Math.min( toPlace, slot.container.getMaxStackSize() - clickedItem.getCount() );
+                                                    if (toPlace == 1) {
+                                                        action = org.bukkit.event.inventory.InventoryAction.PLACE_ONE;
+                                                    } else if (toPlace == cursor.getCount()) {
+                                                        action = org.bukkit.event.inventory.InventoryAction.PLACE_ALL;
+                                                    } else if (toPlace < 0) {
+                                                        action = toPlace != -1 ? org.bukkit.event.inventory.InventoryAction.PICKUP_SOME : org.bukkit.event.inventory.InventoryAction.PICKUP_ONE; // this happens with oversized stacks
+                                                    } else if (toPlace != 0) {
+                                                        action = org.bukkit.event.inventory.InventoryAction.PLACE_SOME;
+                                                    }
+                                                } else if (cursor.getCount() <= slot.getMaxStackSize()) {
+                                                    action = org.bukkit.event.inventory.InventoryAction.SWAP_WITH_CURSOR;
+                                                }
+                                            } else if (cursor.getItem() == clickedItem.getItem() && ItemStack.tagMatches( cursor, clickedItem )) {
+                                                if (clickedItem.getCount() >= 0) {
+                                                    if (clickedItem.getCount() + cursor.getCount() <= cursor.getMaxStackSize()) {
+                                                        // As of 1.5, this is result slots only
+                                                        action = org.bukkit.event.inventory.InventoryAction.PICKUP_ALL;
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                            break;
+                        // TODO check on updates
+                        case QUICK_MOVE:
+                            if (p_9856_.getButtonNum() == 0) {
+                                click = org.bukkit.event.inventory.ClickType.SHIFT_LEFT;
+                            } else if (p_9856_.getButtonNum() == 1) {
+                                click = org.bukkit.event.inventory.ClickType.SHIFT_RIGHT;
+                            }
+                            if (p_9856_.getButtonNum() == 0 || p_9856_.getButtonNum() == 1) {
+                                if (p_9856_.getSlotNum() < 0) {
+                                    action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                } else {
+                                    net.minecraft.world.inventory.Slot slot = this.player.containerMenu.getSlot( p_9856_.getSlotNum() );
+                                    if (slot != null && slot.mayPickup( this.player ) && slot.hasItem()) {
+                                        action = org.bukkit.event.inventory.InventoryAction.MOVE_TO_OTHER_INVENTORY;
+                                    } else {
+                                        action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                    }
+                                }
+                            }
+                            break;
+                        case SWAP:
+                            if ((p_9856_.getButtonNum() >= 0 && p_9856_.getButtonNum() < 9) || p_9856_.getButtonNum() == 40) {
+                                click = (p_9856_.getButtonNum() == 40) ? org.bukkit.event.inventory.ClickType.SWAP_OFFHAND : org.bukkit.event.inventory.ClickType.NUMBER_KEY;
+                                net.minecraft.world.inventory.Slot clickedSlot = this.player.containerMenu.getSlot( p_9856_.getSlotNum() );
+                                if (clickedSlot.mayPickup( player )) {
+                                    ItemStack hotbar = this.player.getInventory().getItem( p_9856_.getButtonNum() );
+                                    boolean canCleanSwap = hotbar.isEmpty() || (clickedSlot.container == player.getInventory() && clickedSlot.mayPlace( hotbar )); // the slot will accept the hotbar item
+                                    if (clickedSlot.hasItem()) {
+                                        if (canCleanSwap) {
+                                            action = org.bukkit.event.inventory.InventoryAction.HOTBAR_SWAP;
+                                        } else {
+                                            action = org.bukkit.event.inventory.InventoryAction.HOTBAR_MOVE_AND_READD;
+                                        }
+                                    } else if (!clickedSlot.hasItem() && !hotbar.isEmpty() && clickedSlot.mayPlace( hotbar )) {
+                                        action = org.bukkit.event.inventory.InventoryAction.HOTBAR_SWAP;
+                                    } else {
+                                        action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                    }
+                                } else {
+                                    action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                }
+                            }
+                            break;
+                        case CLONE:
+                            if (p_9856_.getButtonNum() == 2) {
+                                click = org.bukkit.event.inventory.ClickType.MIDDLE;
+                                if (p_9856_.getSlotNum() < 0) {
+                                    action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                } else {
+                                    net.minecraft.world.inventory.Slot slot = this.player.containerMenu.getSlot( p_9856_.getSlotNum() );
+                                    if (slot != null && slot.hasItem() && player.getAbilities().instabuild && player.containerMenu.getCarried().isEmpty()) {
+                                        action = org.bukkit.event.inventory.InventoryAction.CLONE_STACK;
+                                    } else {
+                                        action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                    }
+                                }
+                            } else {
+                                click = org.bukkit.event.inventory.ClickType.UNKNOWN;
+                                action = org.bukkit.event.inventory.InventoryAction.UNKNOWN;
+                            }
+                            break;
+                        case THROW:
+                            if (p_9856_.getSlotNum() >= 0) {
+                                if (p_9856_.getButtonNum() == 0) {
+                                    click = org.bukkit.event.inventory.ClickType.DROP;
+                                    net.minecraft.world.inventory.Slot slot = this.player.containerMenu.getSlot( p_9856_.getSlotNum() );
+                                    if (slot != null && slot.hasItem() && slot.mayPickup( player ) && !slot.getItem().isEmpty() && slot.getItem().getItem() != Item.byBlock( Blocks.AIR )) {
+                                        action = org.bukkit.event.inventory.InventoryAction.DROP_ONE_SLOT;
+                                    } else {
+                                        action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                    }
+                                } else if (p_9856_.getButtonNum() == 1) {
+                                    click = org.bukkit.event.inventory.ClickType.CONTROL_DROP;
+                                    net.minecraft.world.inventory.Slot slot = this.player.containerMenu.getSlot( p_9856_.getSlotNum() );
+                                    if (slot != null && slot.hasItem() && slot.mayPickup( player ) && !slot.getItem().isEmpty() && slot.getItem().getItem() != Item.byBlock( Blocks.AIR )) {
+                                        action = org.bukkit.event.inventory.InventoryAction.DROP_ALL_SLOT;
+                                    } else {
+                                        action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                    }
+                                }
+                            } else {
+                                // Sane default (because this happens when they are holding nothing. Don't ask why.)
+                                click = org.bukkit.event.inventory.ClickType.LEFT;
+                                if (p_9856_.getButtonNum() == 1) {
+                                    click = org.bukkit.event.inventory.ClickType.RIGHT;
+                                }
+                                action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                            }
+                            break;
+                        case QUICK_CRAFT:
+                            this.player.containerMenu.clicked( p_9856_.getSlotNum(), p_9856_.getButtonNum(), p_9856_.getClickType(), this.player );
+                            break;
+                        case PICKUP_ALL:
+                            click = org.bukkit.event.inventory.ClickType.DOUBLE_CLICK;
+                            action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                            if (p_9856_.getSlotNum() >= 0 && !this.player.containerMenu.getCarried().isEmpty()) {
+                                ItemStack cursor = this.player.containerMenu.getCarried();
+                                action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                // Quick check for if we have any of the item
+                                if (inventory.getTopInventory().contains( org.bukkit.craftbukkit.v1_18_R2.util.CraftMagicNumbers.getMaterial( cursor.getItem() ) ) || inventory.getBottomInventory().contains( org.bukkit.craftbukkit.v1_18_R2.util.CraftMagicNumbers.getMaterial( cursor.getItem() ) )) {
+                                    action = org.bukkit.event.inventory.InventoryAction.COLLECT_TO_CURSOR;
+                                }
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                    if (p_9856_.getClickType() != net.minecraft.world.inventory.ClickType.QUICK_CRAFT) {
+                        if (click == org.bukkit.event.inventory.ClickType.NUMBER_KEY) {
+                            event = new org.bukkit.event.inventory.InventoryClickEvent( inventory, type, p_9856_.getSlotNum(), click, action, p_9856_.getButtonNum() );
+                        } else {
+                            event = new org.bukkit.event.inventory.InventoryClickEvent( inventory, type, p_9856_.getSlotNum(), click, action );
+                        }
+                        org.bukkit.inventory.Inventory top = inventory.getTopInventory();
+                        if (p_9856_.getSlotNum() == 0 && top instanceof org.bukkit.inventory.CraftingInventory) {
+                            org.bukkit.inventory.Recipe recipe = ((org.bukkit.inventory.CraftingInventory) top).getRecipe();
+                            if (recipe != null) {
+                                if (click == org.bukkit.event.inventory.ClickType.NUMBER_KEY) {
+                                    event = new org.bukkit.event.inventory.CraftItemEvent( recipe, inventory, type, p_9856_.getSlotNum(), click, action, p_9856_.getButtonNum() );
+                                } else {
+                                    event = new org.bukkit.event.inventory.CraftItemEvent( recipe, inventory, type, p_9856_.getSlotNum(), click, action );
+                                }
+                            }
+                        }
+                        if (p_9856_.getSlotNum() == 2 && top instanceof org.bukkit.inventory.SmithingInventory) {
+                            org.bukkit.inventory.ItemStack result = ((org.bukkit.inventory.SmithingInventory) top).getResult();
+                            if (result != null) {
+                                if (click == org.bukkit.event.inventory.ClickType.NUMBER_KEY) {
+                                    event = new org.bukkit.event.inventory.SmithItemEvent( inventory, type, p_9856_.getSlotNum(), click, action, p_9856_.getButtonNum() );
+                                } else {
+                                    event = new org.bukkit.event.inventory.SmithItemEvent( inventory, type, p_9856_.getSlotNum(), click, action );
+                                }
+                            }
+                        }
+                        event.setCancelled( cancelled );
+                        AbstractContainerMenu oldContainer = this.player.containerMenu; // SPIGOT-1224
+                        cserver.getPluginManager().callEvent( event );
+                        if (this.player.containerMenu != oldContainer) {
+                            return;
+                        }
+                        switch (event.getResult()) {
+                            case ALLOW:
+                            case DEFAULT:
+                                this.player.containerMenu.clicked( i, p_9856_.getButtonNum(), p_9856_.getClickType(), this.player );
+                                break;
+                            case DENY:
+                                switch (action) {
+                                    // Modified other slots
+                                    case PICKUP_ALL:
+                                    case MOVE_TO_OTHER_INVENTORY:
+                                    case HOTBAR_MOVE_AND_READD:
+                                    case HOTBAR_SWAP:
+                                    case COLLECT_TO_CURSOR:
+                                    case UNKNOWN:
+                                        this.player.containerMenu.sendAllDataToRemote();
+                                        break;
+                                    // Modified cursor and clicked
+                                    case PICKUP_SOME:
+                                    case PICKUP_HALF:
+                                    case PICKUP_ONE:
+                                    case PLACE_ALL:
+                                    case PLACE_SOME:
+                                    case PLACE_ONE:
+                                    case SWAP_WITH_CURSOR:
+                                        this.player.connection.send( new ClientboundContainerSetSlotPacket( -1, -1, this.player.inventoryMenu.incrementStateId(), this.player.containerMenu.getCarried() ) );
+                                        this.player.connection.send( new ClientboundContainerSetSlotPacket( this.player.containerMenu.containerId, this.player.inventoryMenu.incrementStateId(), p_9856_.getSlotNum(), this.player.containerMenu.getSlot( p_9856_.getSlotNum() ).getItem() ) );
+                                        break;
+                                    // Modified clicked only
+                                    case DROP_ALL_SLOT:
+                                    case DROP_ONE_SLOT:
+                                        this.player.connection.send( new ClientboundContainerSetSlotPacket( this.player.containerMenu.containerId, this.player.inventoryMenu.incrementStateId(), p_9856_.getSlotNum(), this.player.containerMenu.getSlot( p_9856_.getSlotNum() ).getItem() ) );
+                                        break;
+                                    // Modified cursor only
+                                    case DROP_ALL_CURSOR:
+                                    case DROP_ONE_CURSOR:
+                                    case CLONE_STACK:
+                                        this.player.connection.send( new ClientboundContainerSetSlotPacket( -1, -1, this.player.inventoryMenu.incrementStateId(), this.player.containerMenu.getCarried() ) );
+                                        break;
+                                    // Nothing
+                                    case NOTHING:
+                                        break;
+                                }
+                        }
+                        if (event instanceof org.bukkit.event.inventory.CraftItemEvent || event instanceof org.bukkit.event.inventory.SmithItemEvent) {
+                            // Need to update the inventory on crafting to
+                            // correctly support custom recipes
+                            player.containerMenu.sendAllDataToRemote();
+                        }
+                    }
+                    // CraftBukkit end
+
+                    for (Entry<ItemStack> entry : Int2ObjectMaps.fastIterable( p_9856_.getChangedSlots() )) {
+                        this.player.containerMenu.setRemoteSlotNoCopy( entry.getIntKey(), entry.getValue() );
+                    }
+
+                    this.player.containerMenu.setRemoteCarried( p_9856_.getCarriedItem() );
+                    this.player.containerMenu.resumeRemoteUpdates();
+                    if (flag) {
+                        this.player.containerMenu.broadcastFullState();
+                    } else {
+                        this.player.containerMenu.broadcastChanges();
+                    }
+
+                }
+            }
+        }
+    }
+
+    public void handlePlaceRecipe(ServerboundPlaceRecipePacket p_9882_) {
+        PacketUtils.ensureRunningOnSameThread( p_9882_, this, this.player.getLevel() );
+        this.player.resetLastActionTime();
+        if (!this.player.isSpectator() && this.player.containerMenu.containerId == p_9882_.getContainerId() && this.player.containerMenu instanceof RecipeBookMenu) {
+            this.server.getRecipeManager().byKey( p_9882_.getRecipe() ).ifPresent( (p_184200_) -> {
+                ((RecipeBookMenu) this.player.containerMenu).handlePlacement( p_9882_.isShiftDown(), p_184200_, this.player );
+            } );
+        }
+    }
+
+    public void handleContainerButtonClick(ServerboundContainerButtonClickPacket p_9854_) {
+        PacketUtils.ensureRunningOnSameThread( p_9854_, this, this.player.getLevel() );
+        if (this.player.isImmobile()) return; // CraftBukkit
+        this.player.resetLastActionTime();
+        if (this.player.containerMenu.containerId == p_9854_.getContainerId() && !this.player.isSpectator()) {
+            boolean flag = this.player.containerMenu.clickMenuButton( this.player, p_9854_.getButtonId() );
+            if (flag) {
+                this.player.containerMenu.broadcastChanges();
+            }
+        }
+
+    }
+
+    public void handleSetCreativeModeSlot(ServerboundSetCreativeModeSlotPacket p_9915_) {
+        PacketUtils.ensureRunningOnSameThread( p_9915_, this, this.player.getLevel() );
+        if (this.player.gameMode.isCreative()) {
+            boolean flag = p_9915_.getSlotNum() < 0;
+            ItemStack itemstack = p_9915_.getItem();
+            CompoundTag compoundtag = BlockItem.getBlockEntityData( itemstack );
+            if (!itemstack.isEmpty() && compoundtag != null && compoundtag.contains( "x" ) && compoundtag.contains( "y" ) && compoundtag.contains( "z" ) && this.player.getBukkitEntity().hasPermission("minecraft.nbt.copy")) { // Spigot
+                BlockPos blockpos = BlockEntity.getPosFromTag( compoundtag );
+                BlockEntity blockentity = this.player.level.getBlockEntity( blockpos );
+                if (blockentity != null) {
+                    blockentity.saveToItem( itemstack );
+                }
+            }
+
+            boolean flag1 = p_9915_.getSlotNum() >= 1 && p_9915_.getSlotNum() <= 45;
+            boolean flag2 = itemstack.isEmpty() || itemstack.getDamageValue() >= 0 && itemstack.getCount() <= 64 && !itemstack.isEmpty();
+            if (flag || (flag1 && !ItemStack.matches( this.player.inventoryMenu.getSlot( p_9915_.getSlotNum() ).getItem(), p_9915_.getItem() ))) { // Insist on valid slot
+                // CraftBukkit start - Call click event
+                org.bukkit.inventory.InventoryView inventory = this.player.inventoryMenu.getBukkitView();
+                org.bukkit.inventory.ItemStack item = org.bukkit.craftbukkit.v1_18_R2.inventory.CraftItemStack.asBukkitCopy( p_9915_.getItem() );
+                org.bukkit.event.inventory.InventoryType.SlotType type = org.bukkit.event.inventory.InventoryType.SlotType.QUICKBAR;
+                if (flag) {
+                    type = org.bukkit.event.inventory.InventoryType.SlotType.OUTSIDE;
+                } else if (p_9915_.getSlotNum() < 36) {
+                    if (p_9915_.getSlotNum() >= 5 && p_9915_.getSlotNum() < 9) {
+                        type = org.bukkit.event.inventory.InventoryType.SlotType.ARMOR;
+                    } else {
+                        type = org.bukkit.event.inventory.InventoryType.SlotType.CONTAINER;
+                    }
+                }
+                org.bukkit.event.inventory.InventoryCreativeEvent event = new org.bukkit.event.inventory.InventoryCreativeEvent( inventory, type, flag ? -999 : p_9915_.getSlotNum(), item );
+                cserver.getPluginManager().callEvent( event );
+                itemstack = org.bukkit.craftbukkit.v1_18_R2.inventory.CraftItemStack.asNMSCopy( event.getCursor() );
+                switch (event.getResult()) {
+                    case ALLOW:
+                        // Plugin cleared the id / stacksize checks
+                        flag2 = true;
+                        break;
+                    case DEFAULT:
+                        break;
+                    case DENY:
+                        // Reset the slot
+                        if (p_9915_.getSlotNum() >= 0) {
+                            this.player.connection.send( new ClientboundContainerSetSlotPacket( this.player.inventoryMenu.containerId, this.player.inventoryMenu.incrementStateId(), p_9915_.getSlotNum(), this.player.inventoryMenu.getSlot( p_9915_.getSlotNum() ).getItem() ) );
+                            this.player.connection.send( new ClientboundContainerSetSlotPacket( -1, this.player.inventoryMenu.incrementStateId(), -1, ItemStack.EMPTY ) );
+                        }
+                        return;
+                }
+            }
+            // CraftBukkit end
+            if (flag1 && flag2) {
+                this.player.inventoryMenu.getSlot( p_9915_.getSlotNum() ).set( itemstack );
+                this.player.inventoryMenu.broadcastChanges();
+            } else if (flag && flag2 && this.dropSpamTickCount < 200) {
+                this.dropSpamTickCount += 20;
+                this.player.drop( itemstack, true );
+            }
+        }
+
+    }
+
+    public void handleSignUpdate(ServerboundSignUpdatePacket p_9921_) {
+        List<String> list = Stream.of( p_9921_.getLines() ).map( ChatFormatting::stripFormatting ).collect( Collectors.toList() );
+        this.filterTextPacket( list, (p_184205_) -> {
+            this.updateSignText( p_9921_, p_184205_ );
+        } );
+    }
+
+    private void updateSignText(ServerboundSignUpdatePacket p_9923_, List<TextFilter.FilteredText> p_9924_) {
+        if (this.player.isImmobile()) return; // CraftBukkit
+        this.player.resetLastActionTime();
+        ServerLevel serverlevel = this.player.getLevel();
+        BlockPos blockpos = p_9923_.getPos();
+        if (serverlevel.hasChunkAt( blockpos )) {
+            BlockState blockstate = serverlevel.getBlockState( blockpos );
+            BlockEntity blockentity = serverlevel.getBlockEntity( blockpos );
+            if (!(blockentity instanceof SignBlockEntity)) {
+                return;
+            }
+
+            SignBlockEntity signblockentity = (SignBlockEntity) blockentity;
+            if (!signblockentity.isEditable() || !this.player.getUUID().equals( signblockentity.getPlayerWhoMayEdit() )) {
+                LOGGER.warn( "Player {} just tried to change non-editable sign", (Object) this.player.getName().getString() );
+                this.send(blockentity.getUpdatePacket()); // CraftBukkit
+                return;
+            }
+
+            // CraftBukkit start
+            org.bukkit.entity.Player player = this.player.getBukkitEntity();
+            int x = p_9923_.getPos().getX();
+            int y = p_9923_.getPos().getY();
+            int z = p_9923_.getPos().getZ();
+            String[] lines = new String[4];
+
+            for (int i = 0; i < p_9924_.size(); ++i) {
+                TextFilter.FilteredText textfilter$filteredtext = p_9924_.get( i );
+                if (this.player.isTextFilteringEnabled()) {
+                    lines[i] = ChatFormatting.stripFormatting(new TextComponent(ChatFormatting.stripFormatting(textfilter$filteredtext.getFiltered())).getString());
+                } else {
+                    lines[i] = ChatFormatting.stripFormatting(new TextComponent(ChatFormatting.stripFormatting(textfilter$filteredtext.getRaw())).getString());
+                }
+            }
+
+            org.bukkit.event.block.SignChangeEvent event = new org.bukkit.event.block.SignChangeEvent((org.bukkit.craftbukkit.v1_18_R2.block.CraftBlock) player.getWorld().getBlockAt(x, y, z), this.player.getBukkitEntity(), lines);
+            this.cserver.getPluginManager().callEvent(event);
+            if (!event.isCancelled()) {
+                Component[] components = org.bukkit.craftbukkit.v1_18_R2.block.CraftSign.sanitizeLines(event.getLines());
+                for (int i = 0; i < components.length; i++) {
+                    signblockentity.setMessage(i, components[i]);
+                }
+                signblockentity.isEditable = false;
+            }
+            // CraftBukkit end
+
+            signblockentity.setChanged();
+            serverlevel.sendBlockUpdated( blockpos, blockstate, blockstate, 3 );
+        }
+
+    }
+
+    public void handleKeepAlive(ServerboundKeepAlivePacket p_9870_) {
+        PacketUtils.ensureRunningOnSameThread(p_9870_, this, this.player.getLevel()); // CraftBukkit
+        if (this.keepAlivePending && p_9870_.getId() == this.keepAliveChallenge) {
+            int i = (int) (Util.getMillis() - this.keepAliveTime);
+            this.player.latency = (this.player.latency * 3 + i) / 4;
+            this.keepAlivePending = false;
+        } else if (!this.isSingleplayerOwner()) {
+            this.disconnect( new TranslatableComponent( "disconnect.timeout" ) );
+        }
+
+    }
+
+    public void handlePlayerAbilities(ServerboundPlayerAbilitiesPacket p_9887_) {
+        PacketUtils.ensureRunningOnSameThread( p_9887_, this, this.player.getLevel() );
+        // CraftBukkit start
+        if (this.player.getAbilities().mayfly && this.player.getAbilities().flying != p_9887_.isFlying()) {
+            org.bukkit.event.player.PlayerToggleFlightEvent event = new org.bukkit.event.player.PlayerToggleFlightEvent(this.player.getBukkitEntity(), p_9887_.isFlying());
+            this.cserver.getPluginManager().callEvent(event);
+            if (!event.isCancelled()) {
+                this.player.getAbilities().flying = p_9887_.isFlying(); // Actually set the player's flying status
+            } else {
+                this.player.onUpdateAbilities(); // Tell the player their ability was reverted
+            }
+        }
+        // CraftBukkit end
+    }
+
+    public void handleClientInformation(ServerboundClientInformationPacket p_9845_) {
+        PacketUtils.ensureRunningOnSameThread( p_9845_, this, this.player.getLevel() );
+        this.player.updateOptions( p_9845_ );
+    }
+
+    // CraftBukkit start
+    private static final ResourceLocation CUSTOM_REGISTER = new ResourceLocation("register");
+    private static final ResourceLocation CUSTOM_UNREGISTER = new ResourceLocation("unregister");
+    public void handleCustomPayload(ServerboundCustomPayloadPacket p_9860_) {
+        PacketUtils.ensureRunningOnSameThread( p_9860_, this, this.player.getLevel() );
+        io.netty.buffer.ByteBuf copy = p_9860_.getData().copy();
+        var buf = new byte[copy.readableBytes()];
+        copy.readBytes(buf);
+        net.minecraftforge.server.ServerLifecycleHooks.getCurrentServer().executeIfPossible(() -> {
+            if (net.minecraftforge.server.ServerLifecycleHooks.getCurrentServer().hasStopped() || processedDisconnect)
+                return;
+
+            if (this.connection.isConnected()) {
+                if (p_9860_.identifier.equals(CUSTOM_REGISTER)) {
+                    try {
+                        String channels = new String(buf, java.nio.charset.StandardCharsets.UTF_8);
+                        for (String channel : channels.split("\0")) {
+                            if (!StringUtil.isNullOrEmpty(channel))
+                                this.getCraftPlayer().addChannel(channel);
+                        }
+                    } catch (Exception ex) {
+                        LOGGER.error("Couldn't register custom payload", ex);
+                        this.disconnect("Invalid payload REGISTER!");
+                    }
+                } else if (p_9860_.identifier.equals(CUSTOM_UNREGISTER)) {
+                    try {
+                        final String channels = new String(buf, java.nio.charset.StandardCharsets.UTF_8);
+                        for (String channel : channels.split("\0")) {
+                            if (!StringUtil.isNullOrEmpty(channel))
+                                this.getCraftPlayer().removeChannel(channel);
+                        }
+                    } catch (Exception ex) {
+                        LOGGER.error("Couldn't unregister custom payload", ex);
+                        this.disconnect("Invalid payload UNREGISTER!");
+                    }
+                } else {
+                    try {
+                        this.cserver.getMessenger().dispatchIncomingMessage(this.player.getBukkitEntity(), p_9860_.identifier.toString(), buf);
+                    } catch (Exception ex) {
+                        LOGGER.error("Couldn't dispatch custom payload", ex);
+                        this.disconnect("Invalid custom payload!");
+                    }
+                }
+            }
+        });
+        net.minecraftforge.network.NetworkHooks.onCustomPayload( p_9860_, this.connection );
+    }
+
+    public final boolean isDisconnected() {
+        return !this.player.joining && !this.connection.isConnected();
+    }
+    // CraftBukkit end
+
+    public void handleChangeDifficulty(ServerboundChangeDifficultyPacket p_9839_) {
+        PacketUtils.ensureRunningOnSameThread( p_9839_, this, this.player.getLevel() );
+        if (this.player.hasPermissions( 2 ) || this.isSingleplayerOwner()) {
+            this.server.setDifficulty( p_9839_.getDifficulty(), false );
+        }
+    }
+
+    public void handleLockDifficulty(ServerboundLockDifficultyPacket p_9872_) {
+        PacketUtils.ensureRunningOnSameThread( p_9872_, this, this.player.getLevel() );
+        if (this.player.hasPermissions( 2 ) || this.isSingleplayerOwner()) {
+            this.server.setDifficultyLocked( p_9872_.isLocked() );
+        }
+    }
+
+    public ServerPlayer getPlayer() {
+        return this.player;
+    }
+
+    // CraftBukkit start - add method //Magma - implement ArcLight version
+    public void chat(String s, boolean async) {
+        if (s.isEmpty() || this.player.getChatVisibility() == ChatVisiblity.HIDDEN) {
+            return;
+        }
+        if (!async && s.startsWith("/")) {
             this.handleCommand(s);
-         } else {
-            String s1 = p_143629_.getFiltered();
-            Component component = s1.isEmpty() ? null : new TranslatableComponent("chat.type.text", this.player.getDisplayName(), s1);
-            Component component1 = new TranslatableComponent("chat.type.text", this.player.getDisplayName(), s);
-            this.server.getPlayerList().broadcastMessage(component1, (p_184197_) -> {
-               return this.player.shouldFilterMessageTo(p_184197_) ? component : component1;
-            }, ChatType.CHAT, this.player.getUUID());
-         }
-
-         this.chatSpamTickCount += 20;
-         if (this.chatSpamTickCount > 200 && !this.server.getPlayerList().isOp(this.player.getGameProfile())) {
-            this.disconnect(new TranslatableComponent("disconnect.spam"));
-         }
-
-      }
-   }
-
-   private void handleCommand(String p_9958_) {
-      this.server.getCommands().performCommand(this.player.createCommandSourceStack(), p_9958_);
-   }
-
-   public void handleAnimate(ServerboundSwingPacket p_9926_) {
-      PacketUtils.ensureRunningOnSameThread(p_9926_, this, this.player.getLevel());
-      this.player.resetLastActionTime();
-      this.player.swing(p_9926_.getHand());
-   }
-
-   public void handlePlayerCommand(ServerboundPlayerCommandPacket p_9891_) {
-      PacketUtils.ensureRunningOnSameThread(p_9891_, this, this.player.getLevel());
-      this.player.resetLastActionTime();
-      switch(p_9891_.getAction()) {
-      case PRESS_SHIFT_KEY:
-         this.player.setShiftKeyDown(true);
-         break;
-      case RELEASE_SHIFT_KEY:
-         this.player.setShiftKeyDown(false);
-         break;
-      case START_SPRINTING:
-         this.player.setSprinting(true);
-         break;
-      case STOP_SPRINTING:
-         this.player.setSprinting(false);
-         break;
-      case STOP_SLEEPING:
-         if (this.player.isSleeping()) {
-            this.player.stopSleepInBed(false, true);
-            this.awaitingPositionFromClient = this.player.position();
-         }
-         break;
-      case START_RIDING_JUMP:
-         if (this.player.getVehicle() instanceof PlayerRideableJumping) {
-            PlayerRideableJumping playerrideablejumping1 = (PlayerRideableJumping)this.player.getVehicle();
-            int i = p_9891_.getData();
-            if (playerrideablejumping1.canJump() && i > 0) {
-               playerrideablejumping1.handleStartJump(i);
-            }
-         }
-         break;
-      case STOP_RIDING_JUMP:
-         if (this.player.getVehicle() instanceof PlayerRideableJumping) {
-            PlayerRideableJumping playerrideablejumping = (PlayerRideableJumping)this.player.getVehicle();
-            playerrideablejumping.handleStopJump();
-         }
-         break;
-      case OPEN_INVENTORY:
-         if (this.player.getVehicle() instanceof AbstractHorse) {
-            ((AbstractHorse)this.player.getVehicle()).openInventory(this.player);
-         }
-         break;
-      case START_FALL_FLYING:
-         if (!this.player.tryToStartFallFlying()) {
-            this.player.stopFallFlying();
-         }
-         break;
-      default:
-         throw new IllegalArgumentException("Invalid client command!");
-      }
-
-   }
-
-   public void handleInteract(ServerboundInteractPacket p_9866_) {
-      PacketUtils.ensureRunningOnSameThread(p_9866_, this, this.player.getLevel());
-      ServerLevel serverlevel = this.player.getLevel();
-      final Entity entity = p_9866_.getTarget(serverlevel);
-      this.player.resetLastActionTime();
-      this.player.setShiftKeyDown(p_9866_.isUsingSecondaryAction());
-      if (entity != null) {
-         if (!serverlevel.getWorldBorder().isWithinBounds(entity.blockPosition())) {
-            return;
-         }
-
-         double d0 = 36.0D;
-         if (this.player.distanceToSqr(entity) < 36.0D) {
-            p_9866_.dispatch(new ServerboundInteractPacket.Handler() {
-               private void performInteraction(InteractionHand p_143679_, ServerGamePacketListenerImpl.EntityInteraction p_143680_) {
-                  ItemStack itemstack = ServerGamePacketListenerImpl.this.player.getItemInHand(p_143679_).copy();
-                  InteractionResult interactionresult = p_143680_.run(ServerGamePacketListenerImpl.this.player, entity, p_143679_);
-                  if (interactionresult.consumesAction()) {
-                     CriteriaTriggers.PLAYER_INTERACTED_WITH_ENTITY.trigger(ServerGamePacketListenerImpl.this.player, itemstack, entity);
-                     if (interactionresult.shouldSwing()) {
-                        ServerGamePacketListenerImpl.this.player.swing(p_143679_, true);
-                     }
-                  }
-
-               }
-
-               public void onInteraction(InteractionHand p_143677_) {
-                  this.performInteraction(p_143677_, Player::interactOn);
-               }
-
-               public void onInteraction(InteractionHand p_143682_, Vec3 p_143683_) {
-                  this.performInteraction(p_143682_, (p_143686_, p_143687_, p_143688_) -> {
-                     return p_143687_.interactAt(p_143686_, p_143683_, p_143688_);
-                  });
-               }
-
-               public void onAttack() {
-                  if (!(entity instanceof ItemEntity) && !(entity instanceof ExperienceOrb) && !(entity instanceof AbstractArrow) && entity != ServerGamePacketListenerImpl.this.player) {
-                     ServerGamePacketListenerImpl.this.player.attack(entity);
-                  } else {
-                     ServerGamePacketListenerImpl.this.disconnect(new TranslatableComponent("multiplayer.disconnect.invalid_entity_attacked"));
-                     ServerGamePacketListenerImpl.LOGGER.warn("Player {} tried to attack an invalid entity", (Object)ServerGamePacketListenerImpl.this.player.getName().getString());
-                  }
-               }
-            });
-         }
-      }
-
-   }
-
-   public void handleClientCommand(ServerboundClientCommandPacket p_9843_) {
-      PacketUtils.ensureRunningOnSameThread(p_9843_, this, this.player.getLevel());
-      this.player.resetLastActionTime();
-      ServerboundClientCommandPacket.Action serverboundclientcommandpacket$action = p_9843_.getAction();
-      switch(serverboundclientcommandpacket$action) {
-      case PERFORM_RESPAWN:
-         if (this.player.wonGame) {
-            this.player.wonGame = false;
-            this.player = this.server.getPlayerList().respawn(this.player, true);
-            CriteriaTriggers.CHANGED_DIMENSION.trigger(this.player, Level.END, Level.OVERWORLD);
-         } else {
-            if (this.player.getHealth() > 0.0F) {
-               return;
-            }
-
-            this.player = this.server.getPlayerList().respawn(this.player, false);
-            if (this.server.isHardcore()) {
-               this.player.setGameMode(GameType.SPECTATOR);
-               this.player.getLevel().getGameRules().getRule(GameRules.RULE_SPECTATORSGENERATECHUNKS).set(false, this.server);
-            }
-         }
-         break;
-      case REQUEST_STATS:
-         this.player.getStats().sendStats(this.player);
-      }
-
-   }
-
-   public void handleContainerClose(ServerboundContainerClosePacket p_9858_) {
-      PacketUtils.ensureRunningOnSameThread(p_9858_, this, this.player.getLevel());
-      this.player.doCloseContainer();
-   }
-
-   public void handleContainerClick(ServerboundContainerClickPacket p_9856_) {
-      PacketUtils.ensureRunningOnSameThread(p_9856_, this, this.player.getLevel());
-      this.player.resetLastActionTime();
-      if (this.player.containerMenu.containerId == p_9856_.getContainerId()) {
-         if (this.player.isSpectator()) {
-            this.player.containerMenu.sendAllDataToRemote();
-         } else {
-            int i = p_9856_.getSlotNum();
-            if (!this.player.containerMenu.isValidSlotIndex(i)) {
-               LOGGER.debug("Player {} clicked invalid slot index: {}, available slots: {}", this.player.getName(), i, this.player.containerMenu.slots.size());
-            } else {
-               boolean flag = p_9856_.getStateId() != this.player.containerMenu.getStateId();
-               this.player.containerMenu.suppressRemoteUpdates();
-               this.player.containerMenu.clicked(i, p_9856_.getButtonNum(), p_9856_.getClickType(), this.player);
-
-               for(Entry<ItemStack> entry : Int2ObjectMaps.fastIterable(p_9856_.getChangedSlots())) {
-                  this.player.containerMenu.setRemoteSlotNoCopy(entry.getIntKey(), entry.getValue());
-               }
-
-               this.player.containerMenu.setRemoteCarried(p_9856_.getCarriedItem());
-               this.player.containerMenu.resumeRemoteUpdates();
-               if (flag) {
-                  this.player.containerMenu.broadcastFullState();
-               } else {
-                  this.player.containerMenu.broadcastChanges();
-               }
-
-            }
-         }
-      }
-   }
-
-   public void handlePlaceRecipe(ServerboundPlaceRecipePacket p_9882_) {
-      PacketUtils.ensureRunningOnSameThread(p_9882_, this, this.player.getLevel());
-      this.player.resetLastActionTime();
-      if (!this.player.isSpectator() && this.player.containerMenu.containerId == p_9882_.getContainerId() && this.player.containerMenu instanceof RecipeBookMenu) {
-         this.server.getRecipeManager().byKey(p_9882_.getRecipe()).ifPresent((p_184200_) -> {
-            ((RecipeBookMenu)this.player.containerMenu).handlePlacement(p_9882_.isShiftDown(), p_184200_, this.player);
-         });
-      }
-   }
-
-   public void handleContainerButtonClick(ServerboundContainerButtonClickPacket p_9854_) {
-      PacketUtils.ensureRunningOnSameThread(p_9854_, this, this.player.getLevel());
-      this.player.resetLastActionTime();
-      if (this.player.containerMenu.containerId == p_9854_.getContainerId() && !this.player.isSpectator()) {
-         boolean flag = this.player.containerMenu.clickMenuButton(this.player, p_9854_.getButtonId());
-         if (flag) {
-            this.player.containerMenu.broadcastChanges();
-         }
-      }
-
-   }
-
-   public void handleSetCreativeModeSlot(ServerboundSetCreativeModeSlotPacket p_9915_) {
-      PacketUtils.ensureRunningOnSameThread(p_9915_, this, this.player.getLevel());
-      if (this.player.gameMode.isCreative()) {
-         boolean flag = p_9915_.getSlotNum() < 0;
-         ItemStack itemstack = p_9915_.getItem();
-         CompoundTag compoundtag = BlockItem.getBlockEntityData(itemstack);
-         if (!itemstack.isEmpty() && compoundtag != null && compoundtag.contains("x") && compoundtag.contains("y") && compoundtag.contains("z")) {
-            BlockPos blockpos = BlockEntity.getPosFromTag(compoundtag);
-            BlockEntity blockentity = this.player.level.getBlockEntity(blockpos);
-            if (blockentity != null) {
-               blockentity.saveToItem(itemstack);
-            }
-         }
-
-         boolean flag1 = p_9915_.getSlotNum() >= 1 && p_9915_.getSlotNum() <= 45;
-         boolean flag2 = itemstack.isEmpty() || itemstack.getDamageValue() >= 0 && itemstack.getCount() <= 64 && !itemstack.isEmpty();
-         if (flag1 && flag2) {
-            this.player.inventoryMenu.getSlot(p_9915_.getSlotNum()).set(itemstack);
-            this.player.inventoryMenu.broadcastChanges();
-         } else if (flag && flag2 && this.dropSpamTickCount < 200) {
-            this.dropSpamTickCount += 20;
-            this.player.drop(itemstack, true);
-         }
-      }
-
-   }
-
-   public void handleSignUpdate(ServerboundSignUpdatePacket p_9921_) {
-      List<String> list = Stream.of(p_9921_.getLines()).map(ChatFormatting::stripFormatting).collect(Collectors.toList());
-      this.filterTextPacket(list, (p_184205_) -> {
-         this.updateSignText(p_9921_, p_184205_);
-      });
-   }
-
-   private void updateSignText(ServerboundSignUpdatePacket p_9923_, List<TextFilter.FilteredText> p_9924_) {
-      this.player.resetLastActionTime();
-      ServerLevel serverlevel = this.player.getLevel();
-      BlockPos blockpos = p_9923_.getPos();
-      if (serverlevel.hasChunkAt(blockpos)) {
-         BlockState blockstate = serverlevel.getBlockState(blockpos);
-         BlockEntity blockentity = serverlevel.getBlockEntity(blockpos);
-         if (!(blockentity instanceof SignBlockEntity)) {
-            return;
-         }
-
-         SignBlockEntity signblockentity = (SignBlockEntity)blockentity;
-         if (!signblockentity.isEditable() || !this.player.getUUID().equals(signblockentity.getPlayerWhoMayEdit())) {
-            LOGGER.warn("Player {} just tried to change non-editable sign", (Object)this.player.getName().getString());
-            return;
-         }
-
-         for(int i = 0; i < p_9924_.size(); ++i) {
-            TextFilter.FilteredText textfilter$filteredtext = p_9924_.get(i);
-            if (this.player.isTextFilteringEnabled()) {
-               signblockentity.setMessage(i, new TextComponent(textfilter$filteredtext.getFiltered()));
-            } else {
-               signblockentity.setMessage(i, new TextComponent(textfilter$filteredtext.getRaw()), new TextComponent(textfilter$filteredtext.getFiltered()));
-            }
-         }
-
-         signblockentity.setChanged();
-         serverlevel.sendBlockUpdated(blockpos, blockstate, blockstate, 3);
-      }
-
-   }
-
-   public void handleKeepAlive(ServerboundKeepAlivePacket p_9870_) {
-      if (this.keepAlivePending && p_9870_.getId() == this.keepAliveChallenge) {
-         int i = (int)(Util.getMillis() - this.keepAliveTime);
-         this.player.latency = (this.player.latency * 3 + i) / 4;
-         this.keepAlivePending = false;
-      } else if (!this.isSingleplayerOwner()) {
-         this.disconnect(new TranslatableComponent("disconnect.timeout"));
-      }
-
-   }
-
-   public void handlePlayerAbilities(ServerboundPlayerAbilitiesPacket p_9887_) {
-      PacketUtils.ensureRunningOnSameThread(p_9887_, this, this.player.getLevel());
-      this.player.getAbilities().flying = p_9887_.isFlying() && this.player.getAbilities().mayfly;
-   }
-
-   public void handleClientInformation(ServerboundClientInformationPacket p_9845_) {
-      PacketUtils.ensureRunningOnSameThread(p_9845_, this, this.player.getLevel());
-      this.player.updateOptions(p_9845_);
-   }
-
-   public void handleCustomPayload(ServerboundCustomPayloadPacket p_9860_) {
-   }
-
-   public void handleChangeDifficulty(ServerboundChangeDifficultyPacket p_9839_) {
-      PacketUtils.ensureRunningOnSameThread(p_9839_, this, this.player.getLevel());
-      if (this.player.hasPermissions(2) || this.isSingleplayerOwner()) {
-         this.server.setDifficulty(p_9839_.getDifficulty(), false);
-      }
-   }
-
-   public void handleLockDifficulty(ServerboundLockDifficultyPacket p_9872_) {
-      PacketUtils.ensureRunningOnSameThread(p_9872_, this, this.player.getLevel());
-      if (this.player.hasPermissions(2) || this.isSingleplayerOwner()) {
-         this.server.setDifficultyLocked(p_9872_.isLocked());
-      }
-   }
-
-   public ServerPlayer getPlayer() {
-      return this.player;
-   }
-
-   @FunctionalInterface
-   interface EntityInteraction {
-      InteractionResult run(ServerPlayer p_143695_, Entity p_143696_, InteractionHand p_143697_);
-   }
+        } else if (this.player.getChatVisibility() != ChatVisiblity.SYSTEM) {
+            org.bukkit.entity.Player thisPlayer = this.getCraftPlayer();
+            org.bukkit.event.player.AsyncPlayerChatEvent event = new org.bukkit.event.player.AsyncPlayerChatEvent(async, thisPlayer, s, new org.bukkit.craftbukkit.v1_18_R2.util.LazyPlayerSet(this.server));
+            this.cserver.getPluginManager().callEvent(event);
+            if (org.bukkit.event.player.PlayerChatEvent.getHandlerList().getRegisteredListeners().length != 0) {
+                org.bukkit.event.player.PlayerChatEvent queueEvent = new org.bukkit.event.player.PlayerChatEvent(thisPlayer, event.getMessage(), event.getFormat(), event.getRecipients());
+                queueEvent.setCancelled(event.isCancelled());
+                class SyncChat extends org.bukkit.craftbukkit.v1_18_R2.util.Waitable<Object> {
+
+                    @Override
+                    protected Object evaluate() {
+                        org.bukkit.Bukkit.getPluginManager().callEvent(queueEvent);
+                        if (queueEvent.isCancelled()) {
+                            return null;
+                        }
+                        String message = String.format(queueEvent.getFormat(), queueEvent.getPlayer().getDisplayName(), queueEvent.getMessage());
+                        var chatWithLinks = org.bukkit.craftbukkit.v1_18_R2.util.CraftChatMessage.fromStringOrNull(message);
+                        if (chatWithLinks == null) return null;
+                        var event = net.minecraftforge.common.ForgeHooks.onServerChatEvent(ServerGamePacketListenerImpl.this, queueEvent.getMessage(), net.minecraftforge.common.ForgeHooks.newChatWithLinks(message), queueEvent.getMessage(), chatWithLinks);
+                        var component = event == null ? null : event.getComponent();
+                        if (component == null) return null;
+                        org.bukkit.Bukkit.getConsoleSender().sendMessage(org.bukkit.craftbukkit.v1_18_R2.util.CraftChatMessage.fromComponent(component));
+                        if (((org.bukkit.craftbukkit.v1_18_R2.util.LazyPlayerSet) queueEvent.getRecipients()).isLazy()) {
+                            for (ServerPlayer player : server.getPlayerList().players) {
+                                player.sendMessage(component, thisPlayer.getUniqueId());
+                            }
+                        } else {
+                            for (org.bukkit.entity.Player player2 : queueEvent.getRecipients()) {
+                                ((org.bukkit.craftbukkit.v1_18_R2.entity.CraftPlayer) player2).getHandle().sendMessage(component, thisPlayer.getUniqueId());
+                            }
+                        }
+                        return null;
+                    }
+                }
+                org.bukkit.craftbukkit.v1_18_R2.util.Waitable<Object> waitable = new SyncChat();
+                if (async) {
+                    this.server.processQueue.add(waitable);
+                } else {
+                    waitable.run();
+                }
+                try {
+                    waitable.get();
+                    return;
+                } catch (InterruptedException e2) {
+                    Thread.currentThread().interrupt();
+                    return;
+                } catch (java.util.concurrent.ExecutionException e) {
+                    throw new RuntimeException("Exception processing chat event", e.getCause());
+                }
+            }
+            if (event.isCancelled()) {
+                return;
+            }
+            s = String.format(event.getFormat(), event.getPlayer().getDisplayName(), event.getMessage());
+            Component chatWithLinks = org.bukkit.craftbukkit.v1_18_R2.util.CraftChatMessage.fromStringOrNull(s);
+            if (chatWithLinks == null) return;
+            class ForgeChat extends org.bukkit.craftbukkit.v1_18_R2.util.Waitable<Void> {
+
+                @Override
+                protected Void evaluate() {
+                    // this is called on main thread
+                    var chatEvent = net.minecraftforge.common.ForgeHooks.onServerChatEvent(ServerGamePacketListenerImpl.this, event.getMessage(), chatWithLinks, event.getMessage(), chatWithLinks);
+                    var component = chatEvent != null ? chatEvent.getComponent() : null;
+                    if (component == null) return null;
+                    org.bukkit.Bukkit.getConsoleSender().sendMessage(org.bukkit.craftbukkit.v1_18_R2.util.CraftChatMessage.fromComponent(component));
+                    if (((org.bukkit.craftbukkit.v1_18_R2.util.LazyPlayerSet) event.getRecipients()).isLazy()) {
+                        for (ServerPlayer recipient : server.getPlayerList().players) {
+                            recipient.sendMessage(component, thisPlayer.getUniqueId());
+                        }
+                    } else {
+                        for (org.bukkit.entity.Player recipient2 : event.getRecipients()) {
+                            ((org.bukkit.craftbukkit.v1_18_R2.entity.CraftPlayer) recipient2).getHandle().sendMessage(component, thisPlayer.getUniqueId());
+                        }
+                    }
+                    return null;
+                }
+            }
+            org.bukkit.craftbukkit.v1_18_R2.util.Waitable<Void> waitable = new ForgeChat();
+            if (async) {
+               this.server.processQueue.add(waitable);
+            } else {
+                waitable.run();
+            }
+        }
+    }
+
+    public void teleport(org.bukkit.Location dest) {
+        this.player.setLevel(((org.bukkit.craftbukkit.v1_18_R2.CraftWorld)dest.getWorld()).getHandle());
+        internalTeleport( dest.getX(), dest.getY(), dest.getZ(), dest.getYaw(), dest.getPitch(), Collections.emptySet(), true );
+    }
+
+    @FunctionalInterface
+    interface EntityInteraction {
+        InteractionResult run(ServerPlayer p_143695_, Entity p_143696_, InteractionHand p_143697_);
+    }
 }
